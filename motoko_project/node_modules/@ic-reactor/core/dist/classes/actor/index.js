"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorManager = void 0;
/* eslint-disable no-console */
const agent_1 = require("@dfinity/agent");
const helper_1 = require("../../utils/helper");
const candid_1 = require("@dfinity/candid");
const utils_1 = require("../../utils");
class ActorManager {
    constructor(actorConfig) {
        this._actor = null;
        this._subscribers = [];
        this.updateState = (newState, action) => {
            this.actorStore.setState((state) => (Object.assign(Object.assign({}, state), newState)), false, action);
        };
        this.updateMethodState = (method, hash, newState) => {
            this.actorStore.setState((state) => {
                const methodState = state.methodState[method] || {};
                const currentMethodState = methodState[hash] || DEFAULT_STATE;
                const updatedMethodState = Object.assign(Object.assign({}, methodState), { [hash]: Object.assign(Object.assign({}, currentMethodState), newState) });
                return Object.assign(Object.assign({}, state), { methodState: Object.assign(Object.assign({}, state.methodState), { [method]: updatedMethodState }) });
            }, false, method);
        };
        this.initialize = (options) => __awaiter(this, void 0, void 0, function* () {
            yield this._agentManager.updateAgent(options);
        });
        this.extractInterface = () => {
            return this._idlFactory({ IDL: candid_1.IDL });
        };
        this.extractMethodAttributes = () => {
            const iface = this.extractInterface();
            const methodAttributesArray = iface._fields.map(([name, func]) => ({
                name: name,
                attributes: {
                    numberOfArgs: func.argTypes.length,
                    type: ((0, helper_1.isQuery)(func) ? "query" : "update"),
                    validate: (arg) => func.argTypes.some((t, i) => t.covariant(arg[i])),
                },
            }));
            methodAttributesArray.sort((a, b) => {
                if (a.attributes.type === b.attributes.type) {
                    return a.attributes.numberOfArgs - b.attributes.numberOfArgs;
                }
                return a.attributes.type === "query" ? -1 : 1;
            });
            return methodAttributesArray.reduce((acc, { name, attributes }) => {
                acc[name] = attributes;
                return acc;
            }, {});
        };
        this.extractVisitor = () => {
            const iface = this.extractInterface();
            return iface._fields.reduce((acc, service) => {
                const functionName = service[0];
                const type = service[1];
                const visit = ((extractorClass, data) => {
                    return type.accept(extractorClass, data);
                });
                acc[functionName] = visit;
                return acc;
            }, {});
        };
        this.initializeActor = (agent) => {
            console.info(`Initializing actor ${this.canisterId} on ${this._agentManager.getNetwork()} network`);
            const { _idlFactory, canisterId } = this;
            this.updateState({
                initializing: true,
                initialized: false,
                methodState: {},
            }, "initializing");
            try {
                if (!agent) {
                    throw new Error("Agent not initialized");
                }
                this._actor = agent_1.Actor.createActor(_idlFactory, {
                    agent,
                    canisterId,
                });
                if (!this._actor) {
                    throw new Error("Failed to initialize actor");
                }
                this.updateState({
                    initializing: false,
                    initialized: true,
                }, "initialized");
            }
            catch (error) {
                console.error("Error in initializeActor:", error);
                this.updateState({ error: error, initializing: false }, "error");
            }
        };
        this._getActorMethod = (functionName) => {
            if (!this._actor) {
                throw new Error("Actor not initialized");
            }
            if (!this._actor[functionName] ||
                typeof this._actor[functionName] !== "function") {
                throw new Error(`Method ${String(functionName)} not found`);
            }
            return this._actor[functionName];
        };
        this.callMethod = (functionName, ...args) => __awaiter(this, void 0, void 0, function* () {
            const method = this._getActorMethod(functionName);
            const data = yield method(...args);
            return data;
        });
        this.callMethodWithOptions = (options) => {
            return (functionName, ...args) => __awaiter(this, void 0, void 0, function* () {
                const method = this._getActorMethod(functionName);
                const data = yield method.withOptions(options)(...args);
                return data;
            });
        };
        // actor store
        this.getActor = () => {
            return this._actor;
        };
        this.getState = () => {
            return this.actorStore.getState();
        };
        this.subscribeActorState = (listener) => {
            const unsubscribe = this.actorStore.subscribe(listener);
            this._subscribers.push(unsubscribe);
            return unsubscribe;
        };
        this.setState = (updater) => {
            return this.actorStore.setState(updater);
        };
        this.cleanup = () => {
            this._unsubscribeAgent();
            this._subscribers.forEach((unsubscribe) => unsubscribe());
        };
        const { agentManager, idlFactory, canisterId, name = canisterId.toString(), withVisitor = false, withDevtools = false, initializeOnCreate = true, } = actorConfig;
        if (!canisterId) {
            throw new Error("CanisterId is required!");
        }
        this.canisterId = canisterId.toString();
        if (!idlFactory) {
            throw new Error("IDLFactory is required!");
        }
        this._idlFactory = idlFactory;
        this.methodAttributes = this.extractMethodAttributes();
        if (!agentManager) {
            throw new Error("AgentManager is required!");
        }
        this._agentManager = agentManager;
        // Initialize stores
        this.actorStore = (0, helper_1.createStoreWithOptionalDevtools)(Object.assign(Object.assign({}, utils_1.ACTOR_INITIAL_STATE), { name }), {
            withDevtools,
            name: "reactor-actor",
            store: canisterId.toString(),
        });
        this._unsubscribeAgent = this._agentManager.subscribeAgent(this.initializeActor, initializeOnCreate);
        if (withVisitor) {
            this.visitFunction = this.extractVisitor();
        }
        else {
            this.visitFunction = emptyVisitor;
        }
    }
    // agent store
    get agentManager() {
        return this._agentManager;
    }
}
exports.ActorManager = ActorManager;
const emptyVisitor = new Proxy({}, {
    get: function (_, prop) {
        throw new Error(`Cannot visit function "${String(prop)}" without initializing the actor with the visitor option, please set the withVisitor option to true when creating the actor manager.`);
    },
});
const DEFAULT_STATE = { data: undefined, error: undefined, loading: false };
