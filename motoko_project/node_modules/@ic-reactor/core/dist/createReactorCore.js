"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createReactorCore = void 0;
const createReactorStore_1 = require("./createReactorStore");
const utils_1 = require("./utils");
/**
 * The Core module is the main entry point for the library.
 * Create a new actor manager with the given options.
 * Its create a new agent manager if not provided.
 *
 * @category Main
 * @includeExample ./packages/core/README.md:32-86
 */
const createReactorCore = (config) => {
    const _a = (0, createReactorStore_1.createReactorStore)(config), { subscribeActorState, updateMethodState, callMethodWithOptions, callMethod, getState, agentManager } = _a, rest = __rest(_a, ["subscribeActorState", "updateMethodState", "callMethodWithOptions", "callMethod", "getState", "agentManager"]);
    const actorMethod = (functionName, args, options = {}) => {
        const requestHash = (0, utils_1.generateRequestHash)(args);
        const updateState = (newState = {}) => {
            updateMethodState(functionName, requestHash, newState);
        };
        updateState();
        try {
            const methodState = ((key) => {
                const state = getState().methodState[functionName][requestHash];
                switch (key) {
                    case "data":
                        return state.data;
                    case "loading":
                        return state.loading;
                    case "error":
                        return state.error;
                    default:
                        return state;
                }
            });
            const subscribe = (callback) => {
                callback(methodState());
                const unsubscribe = subscribeActorState((state) => {
                    const methodState = state.methodState[functionName];
                    const methodStateHash = methodState[requestHash];
                    if (methodStateHash) {
                        callback(methodStateHash);
                    }
                });
                return unsubscribe;
            };
            const call = (replaceArgs) => __awaiter(void 0, void 0, void 0, function* () {
                updateState({
                    loading: true,
                    error: undefined,
                });
                try {
                    const data = yield callMethodWithOptions(options)(functionName, ...(replaceArgs !== null && replaceArgs !== void 0 ? replaceArgs : args));
                    updateState({ data, loading: false });
                    return data;
                }
                catch (error) {
                    updateState({
                        error: error,
                        loading: false,
                    });
                    throw error;
                }
            });
            return {
                requestHash,
                subscribe,
                getState: methodState,
                call,
            };
        }
        catch (error) {
            updateState({
                error: error,
                loading: false,
            });
            throw error;
        }
    };
    const queryCall = (_a) => {
        var { functionName, args = [], refetchOnMount = true, refetchInterval = false } = _a, options = __rest(_a, ["functionName", "args", "refetchOnMount", "refetchInterval"]);
        let intervalId = null;
        const _b = actorMethod(functionName, args, options), { call } = _b, rest = __rest(_b, ["call"]);
        if (refetchInterval) {
            intervalId = setInterval(() => {
                call();
            }, refetchInterval);
        }
        const clearRefetchInterval = () => {
            if (intervalId) {
                clearInterval(intervalId);
            }
        };
        let dataPromise = Promise.resolve();
        if (refetchOnMount)
            dataPromise = call();
        return Object.assign(Object.assign({}, rest), { call, dataPromise, intervalId, clearRefetchInterval });
    };
    const updateCall = (_a) => {
        var { functionName, args = [] } = _a, options = __rest(_a, ["functionName", "args"]);
        return actorMethod(functionName, args, options);
    };
    return Object.assign(Object.assign({ getState,
        queryCall,
        updateCall,
        callMethod,
        callMethodWithOptions,
        subscribeActorState }, agentManager), rest);
};
exports.createReactorCore = createReactorCore;
