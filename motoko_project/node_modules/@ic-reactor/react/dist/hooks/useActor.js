"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useActor = void 0;
const core_1 = require("@ic-reactor/core");
const react_1 = require("react");
const helpers_1 = require("../helpers");
const adapter_1 = require("../context/adapter");
const agent_1 = require("../context/agent");
/**
 * A comprehensive hook that manages both the fetching of Candid interfaces
 * and the initialization of actor stores for Internet Computer (IC) canisters.
 * It simplifies the process of interacting with canisters by encapsulating
 * the logic for Candid retrieval and actor store management.
 *
 * You can use react context to share the actor hooks across your application.
 *
 * @example
 * ```tsx
 * import { AgentProvider, extractActorHooks, useActor } from "@ic-reactor/react"
 * import { createContext } from "react"
 * import type { ActorHooks } from "@ic-reactor/react/dist/types"
 * // With this import, you can have type safety for the actor's interface.
 * // You can get it from the `.did.d.ts` file generated by the DFX tool.
 * // or from dashboard https://dashboard.internetcomputer.org/canisters/<canister-id>
 * import type { Ledger } from "../declarations/ledger"
 *
 * const ActorContext = createContext<ActorHooks<Ledger> | null>(null)
 *
 * export const { useQueryCall, useUpdateCall } = extractActorHooks(ActorContext)
 *
 * const LedgerActor = ({ children }) => {
 *   const { hooks, fetching, fetchError } = useActor<Ledger>({
 *     canisterId: "ryjl3-tyaaa-aaaaa-aaaba-cai", // ICP Ledger canister
 *     idlFactory // optional: it will be fetched using CandidAdapter
 *   })
 *
 *   return (
 *     <ActorContext.Provider value={hooks}>
 *       <h2>IC Canister Interaction</h2>
 *       {fetching && <p>Loading Candid interface...</p>}
 *       {fetchError && <p>Error: {fetchError}</p>}
 *       {hooks && children}
 *     </ActorContext.Provider>
 *   )
 * }
 * // later in the code
 * const CanisterName = () => {
 *   const { data } = useQueryCall({
 *     functionName: "name",
 *   })
 *
 *   return (
 *     <div>
 *       <h3>Query Call</h3>
 *       <p>Result: {JSON.stringify(data)}</p>
 *     </div>
 *   )
 * }
 *
 * const App = () => (
 *   <AgentProvider withDevtools>
 *     <CandidAdapterProvider>
 *      <LedgerActor>
 *       <CanisterName />
 *      </LedgerActor>
 *    </CandidAdapterProvider>
 *   </AgentProvider>
 * )
 *
 * export default App
 * ```
 */
const useActor = (config) => {
    const { canisterId, candidString, idlFactory: maybeIdlFactory } = config, actorConfig = __rest(config, ["canisterId", "candidString", "idlFactory"]);
    if (!canisterId) {
        throw new Error("canisterId is required");
    }
    const [actorManager, setActorManager] = (0, react_1.useState)(null);
    (0, react_1.useEffect)(() => {
        if ((actorManager === null || actorManager === void 0 ? void 0 : actorManager.canisterId) !== canisterId.toString()) {
            setActorManager(null);
        }
        return actorManager === null || actorManager === void 0 ? void 0 : actorManager.cleanup();
    }, [canisterId, actorManager]);
    const [{ fetching, fetchError }, setState] = (0, react_1.useState)({
        fetching: false,
        fetchError: null,
    });
    const candidAdapter = (0, adapter_1.useCandidAdapter)();
    const authenticating = (0, agent_1.useAuthState)().authenticating;
    const fetchCandid = (0, react_1.useCallback)(() => __awaiter(void 0, void 0, void 0, function* () {
        if (fetching)
            return;
        setState({
            fetching: true,
            fetchError: null,
        });
        try {
            const { idlFactory } = yield candidAdapter.getCandidDefinition(canisterId);
            setState({
                fetching: false,
                fetchError: null,
            });
            return idlFactory;
        }
        catch (err) {
            // eslint-disable-next-line no-console
            console.error(err);
            setState({
                fetchError: `Error fetching canister ${canisterId}`,
                fetching: false,
            });
        }
    }), [canisterId]);
    const evaluateCandid = (0, react_1.useCallback)(() => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const definition = yield candidAdapter.dynamicEvalJs(candidString);
            if (typeof (definition === null || definition === void 0 ? void 0 : definition.idlFactory) !== "function") {
                throw new Error("Error evaluating Candid definition");
            }
            return definition.idlFactory;
        }
        catch (err) {
            // eslint-disable-next-line no-console
            console.error(err);
            setState({
                fetchError: `Error evaluating Candid definition, ${err}`,
                fetching: false,
            });
        }
    }), [candidString]);
    const agentManager = (0, agent_1.useAgentManager)();
    const initialActorManager = (0, react_1.useCallback)((idlFactory) => {
        if (authenticating || !idlFactory)
            return;
        const actorManager = (0, core_1.createActorManager)(Object.assign({ agentManager,
            idlFactory,
            canisterId }, actorConfig));
        setActorManager(actorManager);
    }, [canisterId, agentManager, authenticating]);
    const handleActorInitialization = (0, react_1.useCallback)(() => __awaiter(void 0, void 0, void 0, function* () {
        if (authenticating)
            return;
        if (maybeIdlFactory) {
            initialActorManager(maybeIdlFactory);
            return;
        }
        if (!candidAdapter) {
            throw new Error("CandidAdapter is necessary to fetch the Candid interface. Please ensure your application is wrapped with the CandidAdapterProvider, or provide the idlFactory directly.");
        }
        let idlFactory;
        if (candidString) {
            idlFactory = yield evaluateCandid();
        }
        else {
            idlFactory = yield fetchCandid();
        }
        initialActorManager(idlFactory);
    }), [fetchCandid, evaluateCandid, maybeIdlFactory, initialActorManager]);
    (0, react_1.useEffect)(() => {
        handleActorInitialization();
    }, [handleActorInitialization]);
    const hooks = (0, react_1.useMemo)(() => {
        if (!actorManager)
            return null;
        return (0, helpers_1.actorHooks)(actorManager);
    }, [actorManager]);
    return { hooks, authenticating, fetching, fetchError };
};
exports.useActor = useActor;
