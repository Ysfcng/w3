"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.authHooks = void 0;
const react_1 = __importDefault(require("react"));
const zustand_1 = require("zustand");
const utils_1 = require("@ic-reactor/core/dist/utils");
const authHooks = (agentManager) => {
    const { authenticate: authenticator, getIsLocal, getAuth, authStore, } = agentManager;
    const useAuthState = () => (0, zustand_1.useStore)(authStore);
    const useUserPrincipal = () => { var _a, _b; return (_b = (_a = useAuthState()) === null || _a === void 0 ? void 0 : _a.identity) === null || _b === void 0 ? void 0 : _b.getPrincipal(); };
    const useAuth = ({ onAuthentication, onAuthenticationSuccess, onAuthenticationFailure, onLogin, onLoginSuccess, onLoginError, onLoggedOut, } = {}) => {
        const network = react_1.default.useRef("ic");
        const [loginState, setLoginState] = react_1.default.useState({
            loading: false,
            error: undefined,
        });
        const { authenticated, authenticating, error, identity } = useAuthState();
        const authenticate = react_1.default.useCallback(() => __awaiter(void 0, void 0, void 0, function* () {
            const authenticatePromise = new Promise((resolve, reject) => {
                authenticator()
                    .then((identity) => {
                    onAuthenticationSuccess === null || onAuthenticationSuccess === void 0 ? void 0 : onAuthenticationSuccess(identity);
                    resolve(identity);
                })
                    .catch((e) => {
                    onAuthenticationFailure === null || onAuthenticationFailure === void 0 ? void 0 : onAuthenticationFailure(e);
                    reject(e);
                });
            });
            onAuthentication === null || onAuthentication === void 0 ? void 0 : onAuthentication(() => authenticatePromise);
            return authenticatePromise;
        }), [
            authenticator,
            onAuthentication,
            onAuthenticationSuccess,
            onAuthenticationFailure,
        ]);
        const login = react_1.default.useCallback((options) => __awaiter(void 0, void 0, void 0, function* () {
            setLoginState({ loading: true, error: undefined });
            const loginPromise = new Promise((resolve, reject) => {
                try {
                    const authClient = getAuth();
                    if (!authClient) {
                        throw new Error("Auth client not initialized");
                    }
                    authClient.login(Object.assign(Object.assign({ identityProvider: getIsLocal()
                            ? utils_1.LOCAL_INTERNET_IDENTITY_PROVIDER
                            : utils_1.IC_INTERNET_IDENTITY_PROVIDER }, options), { onSuccess: (msg) => {
                            authenticate()
                                .then((identity) => {
                                var _a;
                                const principal = identity.getPrincipal();
                                (_a = options === null || options === void 0 ? void 0 : options.onSuccess) === null || _a === void 0 ? void 0 : _a.call(options, msg);
                                onLoginSuccess === null || onLoginSuccess === void 0 ? void 0 : onLoginSuccess(principal);
                                resolve(principal);
                                setLoginState({ loading: false, error: undefined });
                            })
                                .catch((error) => {
                                setLoginState({ loading: false, error });
                                onLoginError === null || onLoginError === void 0 ? void 0 : onLoginError(error);
                                reject(error);
                            });
                        }, onError: (error) => {
                            var _a;
                            (_a = options === null || options === void 0 ? void 0 : options.onError) === null || _a === void 0 ? void 0 : _a.call(options, error);
                            setLoginState({ loading: false, error });
                            onLoginError === null || onLoginError === void 0 ? void 0 : onLoginError(error);
                            reject(error);
                        } }));
                }
                catch (e) {
                    const error = e;
                    setLoginState({ loading: false, error });
                    onLoginError === null || onLoginError === void 0 ? void 0 : onLoginError(error);
                    reject(error);
                }
            });
            onLogin === null || onLogin === void 0 ? void 0 : onLogin(() => loginPromise);
        }), [onLogin, onLoginSuccess, onLoginError, authenticate]);
        const logout = react_1.default.useCallback((options) => __awaiter(void 0, void 0, void 0, function* () {
            const authClient = getAuth();
            if (!authClient) {
                throw new Error("Auth client not initialized");
            }
            yield authClient.logout(options);
            yield authenticate();
            onLoggedOut === null || onLoggedOut === void 0 ? void 0 : onLoggedOut();
        }), [onLoggedOut]);
        react_1.default.useEffect(() => agentManager.subscribeAgentState((state) => {
            if (network.current !== state.network) {
                network.current = state.network;
                authenticate();
            }
        }), []);
        return {
            authenticated,
            authenticating,
            identity,
            error,
            login,
            logout,
            authenticate,
            loginLoading: loginState.loading,
            loginError: loginState.error,
        };
    };
    return {
        useUserPrincipal,
        useAuthState,
        useAuth,
    };
};
exports.authHooks = authHooks;
