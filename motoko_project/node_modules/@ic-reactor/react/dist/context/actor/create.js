"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createActorContext = void 0;
const react_1 = __importDefault(require("react"));
const useActor_1 = require("../../hooks/useActor");
const extractActorContext_1 = require("../../helpers/extractActorContext");
/**
 * Creates a React context specifically designed for managing the state and interactions with an actor on the Internet Computer (IC) blockchain.
 * This context facilitates the dynamic creation and management of IC actors within React applications, leveraging the provided configuration options.
 *
 * @param reactorParameters A partial configuration object for the actor context, allowing customization and specification of actor-related settings.
 * - `canisterId`: The default Canister ID to be used if not overridden in the `ActorProvider` component.
 * - Other configurations can include properties related to the actor's interaction, such as agent options or authentication requirements.
 *
 * @returns An object containing the `ActorProvider` component and various hooks for interacting with the actor.
 * - `ActorProvider`: A context provider component that allows child components to access and interact with the configured actor.
 * - Hooks: Custom hooks derived from the actor context, facilitating interactions like querying or updating the actor's state.
 *
 * @example
 * ```jsx
 * import React from 'react';
 * import { createActorContext } from '@ic-reactor/react';
 * import { backend, canisterId, idlFactory } from './declarations/candid'; // Assuming 'declarations/candid' is where your actor interface is defined.
 *
 * // Initialize the actor context with configuration options
 * const { ActorProvider, useActorState, useQueryCall, useUpdateCall } = createActorContext<typeof backend>({
 *   canisterId,
 *   idlFactory, // Optional, wrap the ActorProvider with CandidAdapterProvider
 * });
 *
 * // A sample component that utilizes the actor context
 * const App = () => (
 *   <AgentProvider>
 *     <ActorProvider>
 *       <div>
 *         <h1>IC Actor Interaction Example</h1>
 *         <ActorComponent />
 *       </div>
 *     </ActorProvider>
 *   </AgentProvider>
 * );
 *
 * export default App;
 *
 * // A sample component that uses the actor hooks
 * const ActorComponent = () => {
 *   const { data, loading, error } = useQueryCall({
 *      functionName: 'backendMethodName',
 *      args: [],
 *      refetchInterval: 10000,
 *      refetchOnMount: true,
 *   });
  
 *   return (
 *     <div>
 *        {loading && <p>Loading...</p>}
 *        {error && <p>Error: {error.message}</p>}
 *        {data && <p>Actor data: {data}</p>}
 *     </div>
 *   );
 * };
 * ```
 *
 * This function streamlines the process of setting up a context for IC actor interactions within a React app,
 * it provides a type-safe and efficient way to manage actor state and interactions.
 */
function createActorContext(contextConfig = {}) {
    const { canisterId: defaultCanisterId } = contextConfig, defaultConfig = __rest(contextConfig, ["canisterId"]);
    const ActorContext = react_1.default.createContext(null);
    const ActorProvider = (_a) => {
        var { children, canisterId = defaultCanisterId, loadingComponent = react_1.default.createElement("div", null, "Fetching canister..."), authenticatingComponent = react_1.default.createElement("div", null, "Authenticating...") } = _a, restConfig = __rest(_a, ["children", "canisterId", "loadingComponent", "authenticatingComponent"]);
        if (!canisterId) {
            throw new Error("canisterId is required");
        }
        const config = react_1.default.useMemo(() => (Object.assign(Object.assign({}, defaultConfig), restConfig)), [defaultConfig, restConfig]);
        const { fetchError, authenticating, hooks } = (0, useActor_1.useActor)(Object.assign({ canisterId }, config));
        return (react_1.default.createElement(ActorContext.Provider, { value: hooks }, hooks === null
            ? fetchError
                ? fetchError
                : authenticating
                    ? authenticatingComponent
                    : loadingComponent
            : children));
    };
    ActorProvider.displayName = "ActorProvider";
    const ActorHookProvider = ({ hooks, children, }) => {
        return (react_1.default.createElement(ActorContext.Provider, { value: hooks }, children));
    };
    return Object.assign({ ActorProvider,
        ActorHookProvider }, (0, extractActorContext_1.extractActorContext)(ActorContext));
}
exports.createActorContext = createActorContext;
