import { execSync, spawn } from 'node:child_process';
import path from 'node:path';
import fs from 'node:fs';
import { execaCommand } from 'execa';
import { PocketIc } from 'pic-ic';
import { readConfig } from '../mops.js';
import { createActor, idlFactory } from '../declarations/bench/index.js';
import { toolchain } from './toolchain/index.js';
export class Replica {
    constructor(type, cwd, verbose = false) {
        this.verbose = false;
        this.canisters = {};
        this.type = type;
        this.verbose = verbose;
        this.cwd = cwd;
    }
    async start() {
        console.log(`Starting ${this.type} replica...`);
        if (this.type == 'dfx') {
            await this.stop();
            fs.writeFileSync(path.join(this.cwd, 'dfx.json'), JSON.stringify(this.dfxJson(''), null, 2));
            // this.process = spawn('dfx start --background --clean --artificial-delay 0' + (this.verbose ? '' : ' -qqqq'), {cwd: this.cwd, stdio: ['inherit', this.verbose ? 'inherit' : 'ignore', 'inherit']});
            this.process = spawn('dfx', ['start', '--background', '--clean', '--artificial-delay=0', this.verbose ? '' : ' -qqqq'].filter(x => x), { cwd: this.cwd });
        }
        else {
            let pocketIcBin = await toolchain.bin('pocket-ic');
            let config = readConfig();
            if (config.toolchain?.['pocket-ic'] !== '1.0.0') {
                console.error('Currently only pocket-ic 1.0.0 is supported');
                process.exit(1);
            }
            this.pocketIc = await PocketIc.create(pocketIcBin);
            // @ts-ignore
            this.process = this.pocketIc.server.serverProcess;
        }
        await new Promise((resolve, reject) => {
            console.log(1);
            this.process?.on('data', (data) => {
                console.log(111, data);
            });
        });
        return this.process;
    }
    async stop() {
        if (this.type == 'dfx') {
            execSync('dfx stop' + (this.verbose ? '' : ' -qqqq'), { cwd: this.cwd, stdio: ['pipe', this.verbose ? 'inherit' : 'ignore', 'pipe'] });
        }
        else if (this.pocketIc) {
            await this.pocketIc.tearDown();
        }
    }
    async deploy(name, wasm, cwd = process.cwd()) {
        if (this.type === 'dfx') {
            await execaCommand(`dfx deploy ${name} --mode reinstall --yes --identity anonymous`, { cwd, stdio: this.verbose ? 'pipe' : ['pipe', 'ignore', 'pipe'] });
            let canisterId = execSync(`dfx canister id ${name}`, { cwd }).toString().trim();
            let actor = await createActor(canisterId, {
                agentOptions: {
                    host: 'http://127.0.0.1:4944',
                },
            });
            this.canisters[name] = { cwd, canisterId, actor };
        }
        else if (this.pocketIc) {
            let { canisterId, actor } = await this.pocketIc.setupCanister(idlFactory, wasm);
            this.canisters[name] = {
                cwd,
                canisterId: canisterId.toText(),
                actor,
            };
        }
    }
    getActor(name) {
        return this.canisters[name]?.actor;
    }
    getCanisterId(name) {
        return this.canisters[name]?.canisterId || '';
    }
    dfxJson(canisterName) {
        let canisters = {};
        if (canisterName) {
            canisters[canisterName] = {
                type: 'custom',
                wasm: 'canister.wasm',
                candid: 'canister.did',
            };
        }
        return {
            version: 1,
            canisters,
            defaults: {
                build: {
                    packtool: 'mops sources',
                },
            },
            networks: {
                local: {
                    type: 'ephemeral',
                    bind: '127.0.0.1:4944',
                },
            },
        };
    }
}
