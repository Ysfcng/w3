import {
  AnonymousIdentity,
  ED25519_OID,
  SignIdentity,
  ed25519,
  esm_exports as esm_exports3,
  init_ed25519,
  init_esm as init_esm3,
  unwrapDER,
  wrapDER
} from "./chunk-AQCWOSXO.js";
import {
  Principal,
  bufEquals,
  bufFromBufLike,
  esm_exports,
  esm_exports2,
  fromHex,
  init_esm,
  init_esm2,
  init_utils,
  requestIdOf,
  require_src,
  require_src2,
  toHex,
  uint8ToBuf
} from "./chunk-JP4XKRMY.js";
import {
  require_react
} from "./chunk-HS5T2ZWL.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/zustand/esm/middleware.js
var middleware_exports = {};
__export(middleware_exports, {
  combine: () => combine,
  createJSONStorage: () => createJSONStorage,
  devtools: () => devtools,
  persist: () => persist,
  redux: () => redux,
  subscribeWithSelector: () => subscribeWithSelector
});
function createJSONStorage(getStorage, options) {
  let storage;
  try {
    storage = getStorage();
  } catch (e) {
    return;
  }
  const persistStorage = {
    getItem: (name) => {
      var _a;
      const parse = (str2) => {
        if (str2 === null) {
          return null;
        }
        return JSON.parse(str2, options == null ? void 0 : options.reviver);
      };
      const str = (_a = storage.getItem(name)) != null ? _a : null;
      if (str instanceof Promise) {
        return str.then(parse);
      }
      return parse(str);
    },
    setItem: (name, newValue) => storage.setItem(
      name,
      JSON.stringify(newValue, options == null ? void 0 : options.replacer)
    ),
    removeItem: (name) => storage.removeItem(name)
  };
  return persistStorage;
}
var reduxImpl, redux, trackedConnections, getTrackedConnectionState, extractConnectionInformation, devtoolsImpl, devtools, parseJsonThen, subscribeWithSelectorImpl, subscribeWithSelector, combine, toThenable, oldImpl, newImpl, persistImpl, persist;
var init_middleware = __esm({
  "node_modules/zustand/esm/middleware.js"() {
    reduxImpl = (reducer, initial) => (set, _get, api) => {
      api.dispatch = (action) => {
        set((state) => reducer(state, action), false, action);
        return action;
      };
      api.dispatchFromDevtools = true;
      return { dispatch: (...a) => api.dispatch(...a), ...initial };
    };
    redux = reduxImpl;
    trackedConnections = /* @__PURE__ */ new Map();
    getTrackedConnectionState = (name) => {
      const api = trackedConnections.get(name);
      if (!api)
        return {};
      return Object.fromEntries(
        Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])
      );
    };
    extractConnectionInformation = (store, extensionConnector, options) => {
      if (store === void 0) {
        return {
          type: "untracked",
          connection: extensionConnector.connect(options)
        };
      }
      const existingConnection = trackedConnections.get(options.name);
      if (existingConnection) {
        return { type: "tracked", store, ...existingConnection };
      }
      const newConnection = {
        connection: extensionConnector.connect(options),
        stores: {}
      };
      trackedConnections.set(options.name, newConnection);
      return { type: "tracked", store, ...newConnection };
    };
    devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {
      const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;
      let extensionConnector;
      try {
        extensionConnector = (enabled != null ? enabled : true) && window.__REDUX_DEVTOOLS_EXTENSION__;
      } catch (e) {
      }
      if (!extensionConnector) {
        if (enabled) {
          console.warn(
            "[zustand devtools middleware] Please install/enable Redux devtools extension"
          );
        }
        return fn(set, get, api);
      }
      const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);
      let isRecording = true;
      api.setState = (state, replace, nameOrAction) => {
        const r = set(state, replace);
        if (!isRecording)
          return r;
        const action = nameOrAction === void 0 ? { type: anonymousActionType || "anonymous" } : typeof nameOrAction === "string" ? { type: nameOrAction } : nameOrAction;
        if (store === void 0) {
          connection == null ? void 0 : connection.send(action, get());
          return r;
        }
        connection == null ? void 0 : connection.send(
          {
            ...action,
            type: `${store}/${action.type}`
          },
          {
            ...getTrackedConnectionState(options.name),
            [store]: api.getState()
          }
        );
        return r;
      };
      const setStateFromDevtools = (...a) => {
        const originalIsRecording = isRecording;
        isRecording = false;
        set(...a);
        isRecording = originalIsRecording;
      };
      const initialState = fn(api.setState, get, api);
      if (connectionInformation.type === "untracked") {
        connection == null ? void 0 : connection.init(initialState);
      } else {
        connectionInformation.stores[connectionInformation.store] = api;
        connection == null ? void 0 : connection.init(
          Object.fromEntries(
            Object.entries(connectionInformation.stores).map(([key, store2]) => [
              key,
              key === connectionInformation.store ? initialState : store2.getState()
            ])
          )
        );
      }
      if (api.dispatchFromDevtools && typeof api.dispatch === "function") {
        let didWarnAboutReservedActionType = false;
        const originalDispatch = api.dispatch;
        api.dispatch = (...a) => {
          if (a[0].type === "__setState" && !didWarnAboutReservedActionType) {
            console.warn(
              '[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'
            );
            didWarnAboutReservedActionType = true;
          }
          originalDispatch(...a);
        };
      }
      connection.subscribe((message) => {
        var _a;
        switch (message.type) {
          case "ACTION":
            if (typeof message.payload !== "string") {
              console.error(
                "[zustand devtools middleware] Unsupported action format"
              );
              return;
            }
            return parseJsonThen(
              message.payload,
              (action) => {
                if (action.type === "__setState") {
                  if (store === void 0) {
                    setStateFromDevtools(action.state);
                    return;
                  }
                  if (Object.keys(action.state).length !== 1) {
                    console.error(
                      `
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `
                    );
                  }
                  const stateFromDevtools = action.state[store];
                  if (stateFromDevtools === void 0 || stateFromDevtools === null) {
                    return;
                  }
                  if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {
                    setStateFromDevtools(stateFromDevtools);
                  }
                  return;
                }
                if (!api.dispatchFromDevtools)
                  return;
                if (typeof api.dispatch !== "function")
                  return;
                api.dispatch(action);
              }
            );
          case "DISPATCH":
            switch (message.payload.type) {
              case "RESET":
                setStateFromDevtools(initialState);
                if (store === void 0) {
                  return connection == null ? void 0 : connection.init(api.getState());
                }
                return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
              case "COMMIT":
                if (store === void 0) {
                  connection == null ? void 0 : connection.init(api.getState());
                  return;
                }
                return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
              case "ROLLBACK":
                return parseJsonThen(message.state, (state) => {
                  if (store === void 0) {
                    setStateFromDevtools(state);
                    connection == null ? void 0 : connection.init(api.getState());
                    return;
                  }
                  setStateFromDevtools(state[store]);
                  connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
                });
              case "JUMP_TO_STATE":
              case "JUMP_TO_ACTION":
                return parseJsonThen(message.state, (state) => {
                  if (store === void 0) {
                    setStateFromDevtools(state);
                    return;
                  }
                  if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {
                    setStateFromDevtools(state[store]);
                  }
                });
              case "IMPORT_STATE": {
                const { nextLiftedState } = message.payload;
                const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;
                if (!lastComputedState)
                  return;
                if (store === void 0) {
                  setStateFromDevtools(lastComputedState);
                } else {
                  setStateFromDevtools(lastComputedState[store]);
                }
                connection == null ? void 0 : connection.send(
                  null,
                  // FIXME no-any
                  nextLiftedState
                );
                return;
              }
              case "PAUSE_RECORDING":
                return isRecording = !isRecording;
            }
            return;
        }
      });
      return initialState;
    };
    devtools = devtoolsImpl;
    parseJsonThen = (stringified, f) => {
      let parsed;
      try {
        parsed = JSON.parse(stringified);
      } catch (e) {
        console.error(
          "[zustand devtools middleware] Could not parse the received json",
          e
        );
      }
      if (parsed !== void 0)
        f(parsed);
    };
    subscribeWithSelectorImpl = (fn) => (set, get, api) => {
      const origSubscribe = api.subscribe;
      api.subscribe = (selector, optListener, options) => {
        let listener = selector;
        if (optListener) {
          const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
          let currentSlice = selector(api.getState());
          listener = (state) => {
            const nextSlice = selector(state);
            if (!equalityFn(currentSlice, nextSlice)) {
              const previousSlice = currentSlice;
              optListener(currentSlice = nextSlice, previousSlice);
            }
          };
          if (options == null ? void 0 : options.fireImmediately) {
            optListener(currentSlice, currentSlice);
          }
        }
        return origSubscribe(listener);
      };
      const initialState = fn(set, get, api);
      return initialState;
    };
    subscribeWithSelector = subscribeWithSelectorImpl;
    combine = (initialState, create2) => (...a) => Object.assign({}, initialState, create2(...a));
    toThenable = (fn) => (input) => {
      try {
        const result = fn(input);
        if (result instanceof Promise) {
          return result;
        }
        return {
          then(onFulfilled) {
            return toThenable(onFulfilled)(result);
          },
          catch(_onRejected) {
            return this;
          }
        };
      } catch (e) {
        return {
          then(_onFulfilled) {
            return this;
          },
          catch(onRejected) {
            return toThenable(onRejected)(e);
          }
        };
      }
    };
    oldImpl = (config, baseOptions) => (set, get, api) => {
      let options = {
        getStorage: () => localStorage,
        serialize: JSON.stringify,
        deserialize: JSON.parse,
        partialize: (state) => state,
        version: 0,
        merge: (persistedState, currentState) => ({
          ...currentState,
          ...persistedState
        }),
        ...baseOptions
      };
      let hasHydrated = false;
      const hydrationListeners = /* @__PURE__ */ new Set();
      const finishHydrationListeners = /* @__PURE__ */ new Set();
      let storage;
      try {
        storage = options.getStorage();
      } catch (e) {
      }
      if (!storage) {
        return config(
          (...args) => {
            console.warn(
              `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
            );
            set(...args);
          },
          get,
          api
        );
      }
      const thenableSerialize = toThenable(options.serialize);
      const setItem = () => {
        const state = options.partialize({ ...get() });
        let errorInSync;
        const thenable = thenableSerialize({ state, version: options.version }).then(
          (serializedValue) => storage.setItem(options.name, serializedValue)
        ).catch((e) => {
          errorInSync = e;
        });
        if (errorInSync) {
          throw errorInSync;
        }
        return thenable;
      };
      const savedSetState = api.setState;
      api.setState = (state, replace) => {
        savedSetState(state, replace);
        void setItem();
      };
      const configResult = config(
        (...args) => {
          set(...args);
          void setItem();
        },
        get,
        api
      );
      let stateFromStorage;
      const hydrate = () => {
        var _a;
        if (!storage)
          return;
        hasHydrated = false;
        hydrationListeners.forEach((cb) => cb(get()));
        const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;
        return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {
          if (storageValue) {
            return options.deserialize(storageValue);
          }
        }).then((deserializedStorageValue) => {
          if (deserializedStorageValue) {
            if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
              if (options.migrate) {
                return options.migrate(
                  deserializedStorageValue.state,
                  deserializedStorageValue.version
                );
              }
              console.error(
                `State loaded from storage couldn't be migrated since no migrate function was provided`
              );
            } else {
              return deserializedStorageValue.state;
            }
          }
        }).then((migratedState) => {
          var _a2;
          stateFromStorage = options.merge(
            migratedState,
            (_a2 = get()) != null ? _a2 : configResult
          );
          set(stateFromStorage, true);
          return setItem();
        }).then(() => {
          postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
          hasHydrated = true;
          finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
        }).catch((e) => {
          postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
        });
      };
      api.persist = {
        setOptions: (newOptions) => {
          options = {
            ...options,
            ...newOptions
          };
          if (newOptions.getStorage) {
            storage = newOptions.getStorage();
          }
        },
        clearStorage: () => {
          storage == null ? void 0 : storage.removeItem(options.name);
        },
        getOptions: () => options,
        rehydrate: () => hydrate(),
        hasHydrated: () => hasHydrated,
        onHydrate: (cb) => {
          hydrationListeners.add(cb);
          return () => {
            hydrationListeners.delete(cb);
          };
        },
        onFinishHydration: (cb) => {
          finishHydrationListeners.add(cb);
          return () => {
            finishHydrationListeners.delete(cb);
          };
        }
      };
      hydrate();
      return stateFromStorage || configResult;
    };
    newImpl = (config, baseOptions) => (set, get, api) => {
      let options = {
        storage: createJSONStorage(() => localStorage),
        partialize: (state) => state,
        version: 0,
        merge: (persistedState, currentState) => ({
          ...currentState,
          ...persistedState
        }),
        ...baseOptions
      };
      let hasHydrated = false;
      const hydrationListeners = /* @__PURE__ */ new Set();
      const finishHydrationListeners = /* @__PURE__ */ new Set();
      let storage = options.storage;
      if (!storage) {
        return config(
          (...args) => {
            console.warn(
              `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
            );
            set(...args);
          },
          get,
          api
        );
      }
      const setItem = () => {
        const state = options.partialize({ ...get() });
        return storage.setItem(options.name, {
          state,
          version: options.version
        });
      };
      const savedSetState = api.setState;
      api.setState = (state, replace) => {
        savedSetState(state, replace);
        void setItem();
      };
      const configResult = config(
        (...args) => {
          set(...args);
          void setItem();
        },
        get,
        api
      );
      api.getInitialState = () => configResult;
      let stateFromStorage;
      const hydrate = () => {
        var _a, _b;
        if (!storage)
          return;
        hasHydrated = false;
        hydrationListeners.forEach((cb) => {
          var _a2;
          return cb((_a2 = get()) != null ? _a2 : configResult);
        });
        const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;
        return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
          if (deserializedStorageValue) {
            if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
              if (options.migrate) {
                return options.migrate(
                  deserializedStorageValue.state,
                  deserializedStorageValue.version
                );
              }
              console.error(
                `State loaded from storage couldn't be migrated since no migrate function was provided`
              );
            } else {
              return deserializedStorageValue.state;
            }
          }
        }).then((migratedState) => {
          var _a2;
          stateFromStorage = options.merge(
            migratedState,
            (_a2 = get()) != null ? _a2 : configResult
          );
          set(stateFromStorage, true);
          return setItem();
        }).then(() => {
          postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
          stateFromStorage = get();
          hasHydrated = true;
          finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
        }).catch((e) => {
          postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
        });
      };
      api.persist = {
        setOptions: (newOptions) => {
          options = {
            ...options,
            ...newOptions
          };
          if (newOptions.storage) {
            storage = newOptions.storage;
          }
        },
        clearStorage: () => {
          storage == null ? void 0 : storage.removeItem(options.name);
        },
        getOptions: () => options,
        rehydrate: () => hydrate(),
        hasHydrated: () => hasHydrated,
        onHydrate: (cb) => {
          hydrationListeners.add(cb);
          return () => {
            hydrationListeners.delete(cb);
          };
        },
        onFinishHydration: (cb) => {
          finishHydrationListeners.add(cb);
          return () => {
            finishHydrationListeners.delete(cb);
          };
        }
      };
      if (!options.skipHydration) {
        hydrate();
      }
      return stateFromStorage || configResult;
    };
    persistImpl = (config, baseOptions) => {
      if ("getStorage" in baseOptions || "serialize" in baseOptions || "deserialize" in baseOptions) {
        if (true) {
          console.warn(
            "[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."
          );
        }
        return oldImpl(config, baseOptions);
      }
      return newImpl(config, baseOptions);
    };
    persist = persistImpl;
  }
});

// node_modules/zustand/esm/vanilla.js
var vanilla_exports = {};
__export(vanilla_exports, {
  createStore: () => createStore,
  default: () => vanilla
});
var createStoreImpl, createStore, vanilla;
var init_vanilla = __esm({
  "node_modules/zustand/esm/vanilla.js"() {
    createStoreImpl = (createState) => {
      let state;
      const listeners = /* @__PURE__ */ new Set();
      const setState = (partial, replace) => {
        const nextState = typeof partial === "function" ? partial(state) : partial;
        if (!Object.is(nextState, state)) {
          const previousState = state;
          state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
          listeners.forEach((listener) => listener(state, previousState));
        }
      };
      const getState = () => state;
      const getInitialState = () => initialState;
      const subscribe = (listener) => {
        listeners.add(listener);
        return () => listeners.delete(listener);
      };
      const destroy = () => {
        if (true) {
          console.warn(
            "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
          );
        }
        listeners.clear();
      };
      const api = { setState, getState, getInitialState, subscribe, destroy };
      const initialState = state = createState(setState, getState, api);
      return api;
    };
    createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;
    vanilla = (createState) => {
      if (true) {
        console.warn(
          "[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'."
        );
      }
      return createStore(createState);
    };
  }
});

// node_modules/@ic-reactor/core/dist/utils/helper.js
var require_helper = __commonJS({
  "node_modules/@ic-reactor/core/dist/utils/helper.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value2) {
        return value2 instanceof P ? value2 : new P(function(resolve) {
          resolve(value2);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringToHash = exports.generateActorHash = exports.generateHash = exports.generateRequestHash = exports.jsonToString = exports.isQuery = exports.getProcessEnvNetwork = exports.isInLocalOrDevelopment = exports.importCandidDefinition = exports.createStoreWithOptionalDevtools = void 0;
    var agent_1 = (init_esm3(), __toCommonJS(esm_exports3));
    var middleware_1 = (init_middleware(), __toCommonJS(middleware_exports));
    var vanilla_1 = (init_vanilla(), __toCommonJS(vanilla_exports));
    function createStoreWithOptionalDevtools(initialState, config) {
      if (config.withDevtools) {
        return (0, vanilla_1.createStore)((0, middleware_1.devtools)(() => initialState, Object.assign({ serialize: {
          replacer: (_, value2) => typeof value2 === "bigint" ? value2.toString() : value2
        } }, config)));
      } else {
        return (0, vanilla_1.createStore)(() => initialState);
      }
    }
    exports.createStoreWithOptionalDevtools = createStoreWithOptionalDevtools;
    var importCandidDefinition = (candidDef) => __awaiter(void 0, void 0, void 0, function* () {
      if (typeof window === "undefined") {
        try {
          const loaderFunction = new Function(`
        return import("data:text/javascript;charset=utf-8, ${encodeURIComponent(candidDef)}")
      `);
          return loaderFunction();
        } catch (error) {
          throw new Error(`Error importing candid definition in NodeJs: ${error}`);
        }
      } else {
        try {
          const loaderFunction = new Function(`
        const blob = new Blob([\`${candidDef}\`], { type: "application/javascript" })
        const url = URL.createObjectURL(blob)
        return import(url)
      `);
          return loaderFunction();
        } catch (error) {
          throw new Error(`Error importing candid definition: ${error}`);
        }
      }
    });
    exports.importCandidDefinition = importCandidDefinition;
    var isInLocalOrDevelopment = () => {
      return typeof process !== "undefined" && process.env.DFX_NETWORK === "local";
    };
    exports.isInLocalOrDevelopment = isInLocalOrDevelopment;
    var getProcessEnvNetwork = () => {
      var _a;
      if (typeof process === "undefined")
        return "ic";
      else
        return (_a = process.env.DFX_NETWORK) !== null && _a !== void 0 ? _a : "ic";
    };
    exports.getProcessEnvNetwork = getProcessEnvNetwork;
    function isQuery(func) {
      return func.annotations.includes("query") || func.annotations.includes("composite_query");
    }
    exports.isQuery = isQuery;
    var jsonToString = (json, space = 2) => {
      return JSON.stringify(json, (_, value2) => typeof value2 === "bigint" ? `BigInt(${value2})` : value2, space);
    };
    exports.jsonToString = jsonToString;
    var generateRequestHash = (args = []) => {
      const serializedArgs = (0, agent_1.hashValue)(args);
      return `0x${(0, agent_1.toHex)(serializedArgs)}`;
    };
    exports.generateRequestHash = generateRequestHash;
    var generateHash = (field) => {
      const serializedArgs = JSON.stringify(field);
      return (0, exports.stringToHash)(serializedArgs !== null && serializedArgs !== void 0 ? serializedArgs : "");
    };
    exports.generateHash = generateHash;
    var generateActorHash = (actor) => {
      const serializedArgs = JSON.stringify(actor);
      return (0, exports.stringToHash)(serializedArgs !== null && serializedArgs !== void 0 ? serializedArgs : "");
    };
    exports.generateActorHash = generateActorHash;
    var stringToHash = (str) => {
      const hashBytes = (0, agent_1.hash)(new TextEncoder().encode(str));
      return `0x${toHexString(hashBytes)}`;
    };
    exports.stringToHash = stringToHash;
    function toHexString(bytes) {
      return (0, agent_1.toHex)(bytes);
    }
  }
});

// node_modules/@ic-reactor/core/dist/utils/constants.js
var require_constants = __commonJS({
  "node_modules/@ic-reactor/core/dist/utils/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ACTOR_INITIAL_STATE = exports.LOCAL_INTERNET_IDENTITY_PROVIDER = exports.IC_INTERNET_IDENTITY_PROVIDER = exports.DEFAULT_IC_DIDJS_ID = exports.DEFAULT_LOCAL_DIDJS_ID = exports.LOCAL_HOST_NETWORK_URI = exports.IC_HOST_NETWORK_URI = exports.LOCAL_HOSTS = exports.REMOTE_HOSTS = void 0;
    exports.REMOTE_HOSTS = [".github.dev", ".gitpod.io"];
    exports.LOCAL_HOSTS = ["localhost", "127.0.0.1"];
    exports.IC_HOST_NETWORK_URI = "https://ic0.app";
    exports.LOCAL_HOST_NETWORK_URI = "http://127.0.0.1:4943";
    exports.DEFAULT_LOCAL_DIDJS_ID = "bd3sg-teaaa-aaaaa-qaaba-cai";
    exports.DEFAULT_IC_DIDJS_ID = "a4gq6-oaaaa-aaaab-qaa4q-cai";
    exports.IC_INTERNET_IDENTITY_PROVIDER = "https://identity.ic0.app/#authorize";
    exports.LOCAL_INTERNET_IDENTITY_PROVIDER = "http://rdmx6-jaaaa-aaaaa-aaadq-cai.localhost:4943/#authorize";
    exports.ACTOR_INITIAL_STATE = {
      name: "",
      methodState: {},
      initializing: false,
      initialized: false,
      error: void 0
    };
  }
});

// node_modules/@ic-reactor/core/dist/utils/candid.js
var require_candid = __commonJS({
  "node_modules/@ic-reactor/core/dist/utils/candid.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar((init_esm2(), __toCommonJS(esm_exports2)), exports);
  }
});

// node_modules/@ic-reactor/core/dist/utils/principal.js
var require_principal = __commonJS({
  "node_modules/@ic-reactor/core/dist/utils/principal.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar((init_esm(), __toCommonJS(esm_exports)), exports);
  }
});

// node_modules/@ic-reactor/core/dist/utils/agent.js
var require_agent = __commonJS({
  "node_modules/@ic-reactor/core/dist/utils/agent.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar((init_esm3(), __toCommonJS(esm_exports3)), exports);
  }
});

// node_modules/@ic-reactor/core/dist/utils/index.js
var require_utils = __commonJS({
  "node_modules/@ic-reactor/core/dist/utils/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.agent = exports.principal = exports.candid = void 0;
    __exportStar(require_helper(), exports);
    __exportStar(require_constants(), exports);
    exports.candid = __importStar(require_candid());
    exports.principal = __importStar(require_principal());
    exports.agent = __importStar(require_agent());
  }
});

// node_modules/@ic-reactor/core/dist/classes/actor/index.js
var require_actor = __commonJS({
  "node_modules/@ic-reactor/core/dist/classes/actor/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value2) {
        return value2 instanceof P ? value2 : new P(function(resolve) {
          resolve(value2);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ActorManager = void 0;
    var agent_1 = (init_esm3(), __toCommonJS(esm_exports3));
    var helper_1 = require_helper();
    var candid_1 = (init_esm2(), __toCommonJS(esm_exports2));
    var utils_1 = require_utils();
    var ActorManager = class {
      constructor(actorConfig) {
        this._actor = null;
        this._subscribers = [];
        this.updateState = (newState, action) => {
          this.actorStore.setState((state) => Object.assign(Object.assign({}, state), newState), false, action);
        };
        this.updateMethodState = (method, hash, newState) => {
          this.actorStore.setState((state) => {
            const methodState = state.methodState[method] || {};
            const currentMethodState = methodState[hash] || DEFAULT_STATE;
            const updatedMethodState = Object.assign(Object.assign({}, methodState), { [hash]: Object.assign(Object.assign({}, currentMethodState), newState) });
            return Object.assign(Object.assign({}, state), { methodState: Object.assign(Object.assign({}, state.methodState), { [method]: updatedMethodState }) });
          }, false, method);
        };
        this.initialize = (options) => __awaiter(this, void 0, void 0, function* () {
          yield this._agentManager.updateAgent(options);
        });
        this.extractInterface = () => {
          return this._idlFactory({ IDL: candid_1.IDL });
        };
        this.extractMethodAttributes = () => {
          const iface = this.extractInterface();
          const methodAttributesArray = iface._fields.map(([name2, func]) => ({
            name: name2,
            attributes: {
              numberOfArgs: func.argTypes.length,
              type: (0, helper_1.isQuery)(func) ? "query" : "update",
              validate: (arg) => func.argTypes.some((t, i) => t.covariant(arg[i]))
            }
          }));
          methodAttributesArray.sort((a, b) => {
            if (a.attributes.type === b.attributes.type) {
              return a.attributes.numberOfArgs - b.attributes.numberOfArgs;
            }
            return a.attributes.type === "query" ? -1 : 1;
          });
          return methodAttributesArray.reduce((acc, { name: name2, attributes }) => {
            acc[name2] = attributes;
            return acc;
          }, {});
        };
        this.extractVisitor = () => {
          const iface = this.extractInterface();
          return iface._fields.reduce((acc, service) => {
            const functionName = service[0];
            const type = service[1];
            const visit = (extractorClass, data) => {
              return type.accept(extractorClass, data);
            };
            acc[functionName] = visit;
            return acc;
          }, {});
        };
        this.initializeActor = (agent) => {
          console.info(`Initializing actor ${this.canisterId} on ${this._agentManager.getNetwork()} network`);
          const { _idlFactory, canisterId: canisterId2 } = this;
          this.updateState({
            initializing: true,
            initialized: false,
            methodState: {}
          }, "initializing");
          try {
            if (!agent) {
              throw new Error("Agent not initialized");
            }
            this._actor = agent_1.Actor.createActor(_idlFactory, {
              agent,
              canisterId: canisterId2
            });
            if (!this._actor) {
              throw new Error("Failed to initialize actor");
            }
            this.updateState({
              initializing: false,
              initialized: true
            }, "initialized");
          } catch (error) {
            console.error("Error in initializeActor:", error);
            this.updateState({ error, initializing: false }, "error");
          }
        };
        this._getActorMethod = (functionName) => {
          if (!this._actor) {
            throw new Error("Actor not initialized");
          }
          if (!this._actor[functionName] || typeof this._actor[functionName] !== "function") {
            throw new Error(`Method ${String(functionName)} not found`);
          }
          return this._actor[functionName];
        };
        this.callMethod = (functionName, ...args) => __awaiter(this, void 0, void 0, function* () {
          const method = this._getActorMethod(functionName);
          const data = yield method(...args);
          return data;
        });
        this.callMethodWithOptions = (options) => {
          return (functionName, ...args) => __awaiter(this, void 0, void 0, function* () {
            const method = this._getActorMethod(functionName);
            const data = yield method.withOptions(options)(...args);
            return data;
          });
        };
        this.getActor = () => {
          return this._actor;
        };
        this.getState = () => {
          return this.actorStore.getState();
        };
        this.subscribeActorState = (listener) => {
          const unsubscribe = this.actorStore.subscribe(listener);
          this._subscribers.push(unsubscribe);
          return unsubscribe;
        };
        this.setState = (updater) => {
          return this.actorStore.setState(updater);
        };
        this.cleanup = () => {
          this._unsubscribeAgent();
          this._subscribers.forEach((unsubscribe) => unsubscribe());
        };
        const { agentManager, idlFactory, canisterId, name = canisterId.toString(), withVisitor = false, withDevtools = false, initializeOnCreate = true } = actorConfig;
        if (!canisterId) {
          throw new Error("CanisterId is required!");
        }
        this.canisterId = canisterId.toString();
        if (!idlFactory) {
          throw new Error("IDLFactory is required!");
        }
        this._idlFactory = idlFactory;
        this.methodAttributes = this.extractMethodAttributes();
        if (!agentManager) {
          throw new Error("AgentManager is required!");
        }
        this._agentManager = agentManager;
        this.actorStore = (0, helper_1.createStoreWithOptionalDevtools)(Object.assign(Object.assign({}, utils_1.ACTOR_INITIAL_STATE), { name }), {
          withDevtools,
          name: "reactor-actor",
          store: canisterId.toString()
        });
        this._unsubscribeAgent = this._agentManager.subscribeAgent(this.initializeActor, initializeOnCreate);
        if (withVisitor) {
          this.visitFunction = this.extractVisitor();
        } else {
          this.visitFunction = emptyVisitor;
        }
      }
      // agent store
      get agentManager() {
        return this._agentManager;
      }
    };
    exports.ActorManager = ActorManager;
    var emptyVisitor = new Proxy({}, {
      get: function(_, prop) {
        throw new Error(`Cannot visit function "${String(prop)}" without initializing the actor with the visitor option, please set the withVisitor option to true when creating the actor manager.`);
      }
    });
    var DEFAULT_STATE = { data: void 0, error: void 0, loading: false };
  }
});

// node_modules/@ic-reactor/core/dist/createActorManager.js
var require_createActorManager = __commonJS({
  "node_modules/@ic-reactor/core/dist/createActorManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createActorManager = void 0;
    var actor_1 = require_actor();
    var createActorManager = (config) => {
      return new actor_1.ActorManager(config);
    };
    exports.createActorManager = createActorManager;
  }
});

// node_modules/@dfinity/identity/lib/esm/identity/ed25519.js
function isObject(value2) {
  return value2 !== null && typeof value2 === "object";
}
var __classPrivateFieldSet, __classPrivateFieldGet, _Ed25519PublicKey_rawKey, _Ed25519PublicKey_derKey, _Ed25519KeyIdentity_publicKey, _Ed25519KeyIdentity_privateKey, Ed25519PublicKey, Ed25519KeyIdentity;
var init_ed255192 = __esm({
  "node_modules/@dfinity/identity/lib/esm/identity/ed25519.js"() {
    init_esm3();
    init_esm3();
    init_ed25519();
    __classPrivateFieldSet = function(receiver, state, value2, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    Ed25519PublicKey = class _Ed25519PublicKey {
      // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.
      constructor(key) {
        _Ed25519PublicKey_rawKey.set(this, void 0);
        _Ed25519PublicKey_derKey.set(this, void 0);
        if (key.byteLength !== _Ed25519PublicKey.RAW_KEY_LENGTH) {
          throw new Error("An Ed25519 public key must be exactly 32bytes long");
        }
        __classPrivateFieldSet(this, _Ed25519PublicKey_rawKey, key, "f");
        __classPrivateFieldSet(this, _Ed25519PublicKey_derKey, _Ed25519PublicKey.derEncode(key), "f");
      }
      /**
       * Construct Ed25519PublicKey from an existing PublicKey
       * @param {unknown} maybeKey - existing PublicKey, ArrayBuffer, DerEncodedPublicKey, or hex string
       * @returns {Ed25519PublicKey} Instance of Ed25519PublicKey
       */
      static from(maybeKey) {
        if (typeof maybeKey === "string") {
          const key = fromHex(maybeKey);
          return this.fromRaw(key);
        } else if (isObject(maybeKey)) {
          const key = maybeKey;
          if (isObject(key) && Object.hasOwnProperty.call(key, "__derEncodedPublicKey__")) {
            return this.fromDer(key);
          } else if (ArrayBuffer.isView(key)) {
            const view = key;
            return this.fromRaw(bufFromBufLike(view.buffer));
          } else if (key instanceof ArrayBuffer) {
            return this.fromRaw(key);
          } else if ("rawKey" in key) {
            return this.fromRaw(key.rawKey);
          } else if ("derKey" in key) {
            return this.fromDer(key.derKey);
          } else if ("toDer" in key) {
            return this.fromDer(key.toDer());
          }
        }
        throw new Error("Cannot construct Ed25519PublicKey from the provided key.");
      }
      static fromRaw(rawKey) {
        return new _Ed25519PublicKey(rawKey);
      }
      static fromDer(derKey) {
        return new _Ed25519PublicKey(this.derDecode(derKey));
      }
      static derEncode(publicKey) {
        const key = wrapDER(publicKey, ED25519_OID).buffer;
        key.__derEncodedPublicKey__ = void 0;
        return key;
      }
      static derDecode(key) {
        const unwrapped = unwrapDER(key, ED25519_OID);
        if (unwrapped.length !== this.RAW_KEY_LENGTH) {
          throw new Error("An Ed25519 public key must be exactly 32bytes long");
        }
        return unwrapped;
      }
      get rawKey() {
        return __classPrivateFieldGet(this, _Ed25519PublicKey_rawKey, "f");
      }
      get derKey() {
        return __classPrivateFieldGet(this, _Ed25519PublicKey_derKey, "f");
      }
      toDer() {
        return this.derKey;
      }
      toRaw() {
        return this.rawKey;
      }
    };
    _Ed25519PublicKey_rawKey = /* @__PURE__ */ new WeakMap(), _Ed25519PublicKey_derKey = /* @__PURE__ */ new WeakMap();
    Ed25519PublicKey.RAW_KEY_LENGTH = 32;
    Ed25519KeyIdentity = class _Ed25519KeyIdentity extends SignIdentity {
      // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.
      constructor(publicKey, privateKey) {
        super();
        _Ed25519KeyIdentity_publicKey.set(this, void 0);
        _Ed25519KeyIdentity_privateKey.set(this, void 0);
        __classPrivateFieldSet(this, _Ed25519KeyIdentity_publicKey, Ed25519PublicKey.from(publicKey), "f");
        __classPrivateFieldSet(this, _Ed25519KeyIdentity_privateKey, new Uint8Array(privateKey), "f");
      }
      /**
       * Generate a new Ed25519KeyIdentity.
       * @param seed a 32-byte seed for the private key. If not provided, a random seed will be generated.
       * @returns Ed25519KeyIdentity
       */
      static generate(seed) {
        if (seed && seed.length !== 32) {
          throw new Error("Ed25519 Seed needs to be 32 bytes long.");
        }
        if (!seed)
          seed = ed25519.utils.randomPrivateKey();
        if (bufEquals(seed, new Uint8Array(new Array(32).fill(0)))) {
          console.warn("Seed is all zeros. This is not a secure seed. Please provide a seed with sufficient entropy if this is a production environment.");
        }
        const sk = new Uint8Array(32);
        for (let i = 0; i < 32; i++)
          sk[i] = new Uint8Array(seed)[i];
        const pk = ed25519.getPublicKey(sk);
        return _Ed25519KeyIdentity.fromKeyPair(pk, sk);
      }
      static fromParsedJson(obj) {
        const [publicKeyDer, privateKeyRaw] = obj;
        return new _Ed25519KeyIdentity(Ed25519PublicKey.fromDer(fromHex(publicKeyDer)), fromHex(privateKeyRaw));
      }
      static fromJSON(json) {
        const parsed = JSON.parse(json);
        if (Array.isArray(parsed)) {
          if (typeof parsed[0] === "string" && typeof parsed[1] === "string") {
            return this.fromParsedJson([parsed[0], parsed[1]]);
          } else {
            throw new Error("Deserialization error: JSON must have at least 2 items.");
          }
        }
        throw new Error(`Deserialization error: Invalid JSON type for string: ${JSON.stringify(json)}`);
      }
      static fromKeyPair(publicKey, privateKey) {
        return new _Ed25519KeyIdentity(Ed25519PublicKey.fromRaw(publicKey), privateKey);
      }
      static fromSecretKey(secretKey) {
        const publicKey = ed25519.getPublicKey(new Uint8Array(secretKey));
        return _Ed25519KeyIdentity.fromKeyPair(publicKey, secretKey);
      }
      /**
       * Serialize this key to JSON.
       */
      toJSON() {
        return [toHex(__classPrivateFieldGet(this, _Ed25519KeyIdentity_publicKey, "f").toDer()), toHex(__classPrivateFieldGet(this, _Ed25519KeyIdentity_privateKey, "f"))];
      }
      /**
       * Return a copy of the key pair.
       */
      getKeyPair() {
        return {
          secretKey: __classPrivateFieldGet(this, _Ed25519KeyIdentity_privateKey, "f"),
          publicKey: __classPrivateFieldGet(this, _Ed25519KeyIdentity_publicKey, "f")
        };
      }
      /**
       * Return the public key.
       */
      getPublicKey() {
        return __classPrivateFieldGet(this, _Ed25519KeyIdentity_publicKey, "f");
      }
      /**
       * Signs a blob of data, with this identity's private key.
       * @param challenge - challenge to sign with this identity's secretKey, producing a signature
       */
      async sign(challenge) {
        const blob = new Uint8Array(challenge);
        const signature = uint8ToBuf(ed25519.sign(blob, __classPrivateFieldGet(this, _Ed25519KeyIdentity_privateKey, "f").slice(0, 32)));
        Object.defineProperty(signature, "__signature__", {
          enumerable: false,
          value: void 0
        });
        return signature;
      }
      /**
       * Verify
       * @param sig - signature to verify
       * @param msg - message to verify
       * @param pk - public key
       * @returns - true if the signature is valid, false otherwise
       */
      static verify(sig, msg, pk) {
        const [signature, message, publicKey] = [sig, msg, pk].map((x) => {
          if (typeof x === "string") {
            x = fromHex(x);
          }
          if (x instanceof Uint8Array) {
            x = x.buffer;
          }
          return new Uint8Array(x);
        });
        return ed25519.verify(message, signature, publicKey);
      }
    };
    _Ed25519KeyIdentity_publicKey = /* @__PURE__ */ new WeakMap(), _Ed25519KeyIdentity_privateKey = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/@dfinity/identity/lib/esm/identity/ecdsa.js
function _getEffectiveCrypto(subtleCrypto) {
  if (typeof globalThis !== "undefined" && globalThis["crypto"] && globalThis["crypto"]["subtle"]) {
    return globalThis["crypto"]["subtle"];
  }
  if (subtleCrypto) {
    return subtleCrypto;
  } else if (typeof crypto !== "undefined" && crypto["subtle"]) {
    return crypto.subtle;
  } else {
    throw new CryptoError("Global crypto was not available and none was provided. Please inlcude a SubtleCrypto implementation. See https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto");
  }
}
var CryptoError, ECDSAKeyIdentity;
var init_ecdsa = __esm({
  "node_modules/@dfinity/identity/lib/esm/identity/ecdsa.js"() {
    init_esm3();
    CryptoError = class _CryptoError extends Error {
      constructor(message) {
        super(message);
        this.message = message;
        Object.setPrototypeOf(this, _CryptoError.prototype);
      }
    };
    ECDSAKeyIdentity = class _ECDSAKeyIdentity extends SignIdentity {
      // `fromKeyPair` and `generate` should be used for instantiation, not this constructor.
      constructor(keyPair, derKey, subtleCrypto) {
        super();
        this._keyPair = keyPair;
        this._derKey = derKey;
        this._subtleCrypto = subtleCrypto;
      }
      /**
       * Generates a randomly generated identity for use in calls to the Internet Computer.
       * @param {CryptoKeyOptions} options optional settings
       * @param {CryptoKeyOptions['extractable']} options.extractable - whether the key should allow itself to be used. Set to false for maximum security.
       * @param {CryptoKeyOptions['keyUsages']} options.keyUsages - a list of key usages that the key can be used for
       * @param {CryptoKeyOptions['subtleCrypto']} options.subtleCrypto interface
       * @constructs ECDSAKeyIdentity
       * @returns a {@link ECDSAKeyIdentity}
       */
      static async generate(options) {
        const { extractable = false, keyUsages = ["sign", "verify"], subtleCrypto } = options !== null && options !== void 0 ? options : {};
        const effectiveCrypto = _getEffectiveCrypto(subtleCrypto);
        const keyPair = await effectiveCrypto.generateKey({
          name: "ECDSA",
          namedCurve: "P-256"
        }, extractable, keyUsages);
        const derKey = await effectiveCrypto.exportKey("spki", keyPair.publicKey);
        return new this(keyPair, derKey, effectiveCrypto);
      }
      /**
       * generates an identity from a public and private key. Please ensure that you are generating these keys securely and protect the user's private key
       * @param keyPair a CryptoKeyPair
       * @param subtleCrypto - a SubtleCrypto interface in case one is not available globally
       * @returns an {@link ECDSAKeyIdentity}
       */
      static async fromKeyPair(keyPair, subtleCrypto) {
        const effectiveCrypto = _getEffectiveCrypto(subtleCrypto);
        const derKey = await effectiveCrypto.exportKey("spki", keyPair.publicKey);
        return new _ECDSAKeyIdentity(keyPair, derKey, effectiveCrypto);
      }
      /**
       * Return the internally-used key pair.
       * @returns a CryptoKeyPair
       */
      getKeyPair() {
        return this._keyPair;
      }
      /**
       * Return the public key.
       * @returns an {@link PublicKey & DerCryptoKey}
       */
      getPublicKey() {
        const derKey = this._derKey;
        const key = Object.create(this._keyPair.publicKey);
        key.toDer = function() {
          return derKey;
        };
        return key;
      }
      /**
       * Signs a blob of data, with this identity's private key.
       * @param {ArrayBuffer} challenge - challenge to sign with this identity's secretKey, producing a signature
       * @returns {Promise<Signature>} signature
       */
      async sign(challenge) {
        const params = {
          name: "ECDSA",
          hash: { name: "SHA-256" }
        };
        this._keyPair.privateKey;
        const signature = await this._subtleCrypto.sign(params, this._keyPair.privateKey, challenge);
        return signature;
      }
    };
  }
});

// node_modules/@dfinity/identity/lib/esm/identity/partial.js
var __classPrivateFieldSet2, __classPrivateFieldGet2, _PartialIdentity_inner, PartialIdentity;
var init_partial = __esm({
  "node_modules/@dfinity/identity/lib/esm/identity/partial.js"() {
    init_esm();
    __classPrivateFieldSet2 = function(receiver, state, value2, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
    };
    __classPrivateFieldGet2 = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    PartialIdentity = class {
      constructor(inner) {
        _PartialIdentity_inner.set(this, void 0);
        __classPrivateFieldSet2(this, _PartialIdentity_inner, inner, "f");
      }
      /**
       * The raw public key of this identity.
       */
      get rawKey() {
        return __classPrivateFieldGet2(this, _PartialIdentity_inner, "f").rawKey;
      }
      /**
       * The DER-encoded public key of this identity.
       */
      get derKey() {
        return __classPrivateFieldGet2(this, _PartialIdentity_inner, "f").derKey;
      }
      /**
       * The DER-encoded public key of this identity.
       */
      toDer() {
        return __classPrivateFieldGet2(this, _PartialIdentity_inner, "f").toDer();
      }
      /**
       * The inner {@link PublicKey} used by this identity.
       */
      getPublicKey() {
        return __classPrivateFieldGet2(this, _PartialIdentity_inner, "f");
      }
      /**
       * The {@link Principal} of this identity.
       */
      getPrincipal() {
        return Principal.from(__classPrivateFieldGet2(this, _PartialIdentity_inner, "f").rawKey);
      }
      /**
       * Required for the Identity interface, but cannot implemented for just a public key.
       */
      transformRequest() {
        return Promise.reject("Not implemented. You are attempting to use a partial identity to sign calls, but this identity only has access to the public key.To sign calls, use a DelegationIdentity instead.");
      }
    };
    _PartialIdentity_inner = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/@dfinity/identity/lib/esm/identity/delegation.js
function _parseBlob(value2) {
  if (typeof value2 !== "string" || value2.length < 64) {
    throw new Error("Invalid public key.");
  }
  return fromHex(value2);
}
async function _createSingleDelegation(from, to, expiration, targets) {
  const delegation = new Delegation(
    to.toDer(),
    BigInt(+expiration) * BigInt(1e6),
    // In nanoseconds.
    targets
  );
  const challenge = new Uint8Array([
    ...domainSeparator,
    ...new Uint8Array(requestIdOf(delegation))
  ]);
  const signature = await from.sign(challenge);
  return {
    delegation,
    signature
  };
}
function isDelegationValid(chain, checks) {
  for (const { delegation } of chain.delegations) {
    if (+new Date(Number(delegation.expiration / BigInt(1e6))) <= +Date.now()) {
      return false;
    }
  }
  const scopes = [];
  const maybeScope = checks === null || checks === void 0 ? void 0 : checks.scope;
  if (maybeScope) {
    if (Array.isArray(maybeScope)) {
      scopes.push(...maybeScope.map((s) => typeof s === "string" ? Principal.fromText(s) : s));
    } else {
      scopes.push(typeof maybeScope === "string" ? Principal.fromText(maybeScope) : maybeScope);
    }
  }
  for (const s of scopes) {
    const scope = s.toText();
    for (const { delegation } of chain.delegations) {
      if (delegation.targets === void 0) {
        continue;
      }
      let none = true;
      for (const target of delegation.targets) {
        if (target.toText() === scope) {
          none = false;
          break;
        }
      }
      if (none) {
        return false;
      }
    }
  }
  return true;
}
var cbor, __classPrivateFieldSet3, __classPrivateFieldGet3, __rest, _PartialDelegationIdentity_delegation, domainSeparator, requestDomainSeparator, Delegation, DelegationChain, DelegationIdentity, PartialDelegationIdentity;
var init_delegation = __esm({
  "node_modules/@dfinity/identity/lib/esm/identity/delegation.js"() {
    init_esm3();
    init_esm();
    cbor = __toESM(require_src2());
    init_partial();
    __classPrivateFieldSet3 = function(receiver, state, value2, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
    };
    __classPrivateFieldGet3 = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    domainSeparator = new TextEncoder().encode("ic-request-auth-delegation");
    requestDomainSeparator = new TextEncoder().encode("\nic-request");
    Delegation = class {
      constructor(pubkey, expiration, targets) {
        this.pubkey = pubkey;
        this.expiration = expiration;
        this.targets = targets;
      }
      toCBOR() {
        return cbor.value.map(Object.assign({ pubkey: cbor.value.bytes(this.pubkey), expiration: cbor.value.u64(this.expiration.toString(16), 16) }, this.targets && {
          targets: cbor.value.array(this.targets.map((t) => cbor.value.bytes(t.toUint8Array())))
        }));
      }
      toJSON() {
        return Object.assign({ expiration: this.expiration.toString(16), pubkey: toHex(this.pubkey) }, this.targets && { targets: this.targets.map((p) => p.toHex()) });
      }
    };
    DelegationChain = class _DelegationChain {
      constructor(delegations, publicKey) {
        this.delegations = delegations;
        this.publicKey = publicKey;
      }
      /**
       * Create a delegation chain between two (or more) keys. By default, the expiration time
       * will be very short (15 minutes).
       *
       * To build a chain of more than 2 identities, this function needs to be called multiple times,
       * passing the previous delegation chain into the options argument. For example:
       * @example
       * const rootKey = createKey();
       * const middleKey = createKey();
       * const bottomeKey = createKey();
       *
       * const rootToMiddle = await DelegationChain.create(
       *   root, middle.getPublicKey(), Date.parse('2100-01-01'),
       * );
       * const middleToBottom = await DelegationChain.create(
       *   middle, bottom.getPublicKey(), Date.parse('2100-01-01'), { previous: rootToMiddle },
       * );
       *
       * // We can now use a delegation identity that uses the delegation above:
       * const identity = DelegationIdentity.fromDelegation(bottomKey, middleToBottom);
       * @param from The identity that will delegate.
       * @param to The identity that gets delegated. It can now sign messages as if it was the
       *           identity above.
       * @param expiration The length the delegation is valid. By default, 15 minutes from calling
       *                   this function.
       * @param options A set of options for this delegation. expiration and previous
       * @param options.previous - Another DelegationChain that this chain should start with.
       * @param options.targets - targets that scope the delegation (e.g. Canister Principals)
       */
      static async create(from, to, expiration = new Date(Date.now() + 15 * 60 * 1e3), options = {}) {
        var _a, _b;
        const delegation = await _createSingleDelegation(from, to, expiration, options.targets);
        return new _DelegationChain([...((_a = options.previous) === null || _a === void 0 ? void 0 : _a.delegations) || [], delegation], ((_b = options.previous) === null || _b === void 0 ? void 0 : _b.publicKey) || from.getPublicKey().toDer());
      }
      /**
       * Creates a DelegationChain object from a JSON string.
       * @param json The JSON string to parse.
       */
      static fromJSON(json) {
        const { publicKey, delegations } = typeof json === "string" ? JSON.parse(json) : json;
        if (!Array.isArray(delegations)) {
          throw new Error("Invalid delegations.");
        }
        const parsedDelegations = delegations.map((signedDelegation) => {
          const { delegation, signature } = signedDelegation;
          const { pubkey, expiration, targets } = delegation;
          if (targets !== void 0 && !Array.isArray(targets)) {
            throw new Error("Invalid targets.");
          }
          return {
            delegation: new Delegation(
              _parseBlob(pubkey),
              BigInt("0x" + expiration),
              // expiration in JSON is an hexa string (See toJSON() below).
              targets && targets.map((t) => {
                if (typeof t !== "string") {
                  throw new Error("Invalid target.");
                }
                return Principal.fromHex(t);
              })
            ),
            signature: _parseBlob(signature)
          };
        });
        return new this(parsedDelegations, _parseBlob(publicKey));
      }
      /**
       * Creates a DelegationChain object from a list of delegations and a DER-encoded public key.
       * @param delegations The list of delegations.
       * @param publicKey The DER-encoded public key of the key-pair signing the first delegation.
       */
      static fromDelegations(delegations, publicKey) {
        return new this(delegations, publicKey);
      }
      toJSON() {
        return {
          delegations: this.delegations.map((signedDelegation) => {
            const { delegation, signature } = signedDelegation;
            const { targets } = delegation;
            return {
              delegation: Object.assign({ expiration: delegation.expiration.toString(16), pubkey: toHex(delegation.pubkey) }, targets && {
                targets: targets.map((t) => t.toHex())
              }),
              signature: toHex(signature)
            };
          }),
          publicKey: toHex(this.publicKey)
        };
      }
    };
    DelegationIdentity = class extends SignIdentity {
      constructor(_inner, _delegation) {
        super();
        this._inner = _inner;
        this._delegation = _delegation;
      }
      /**
       * Create a delegation without having access to delegateKey.
       * @param key The key used to sign the reqyests.
       * @param delegation A delegation object created using `createDelegation`.
       */
      static fromDelegation(key, delegation) {
        return new this(key, delegation);
      }
      getDelegation() {
        return this._delegation;
      }
      getPublicKey() {
        return {
          derKey: this._delegation.publicKey,
          toDer: () => this._delegation.publicKey
        };
      }
      sign(blob) {
        return this._inner.sign(blob);
      }
      async transformRequest(request) {
        const { body } = request, fields = __rest(request, ["body"]);
        const requestId = await requestIdOf(body);
        return Object.assign(Object.assign({}, fields), { body: {
          content: body,
          sender_sig: await this.sign(new Uint8Array([...requestDomainSeparator, ...new Uint8Array(requestId)])),
          sender_delegation: this._delegation.delegations,
          sender_pubkey: this._delegation.publicKey
        } });
      }
    };
    PartialDelegationIdentity = class _PartialDelegationIdentity extends PartialIdentity {
      constructor(inner, delegation) {
        super(inner);
        _PartialDelegationIdentity_delegation.set(this, void 0);
        __classPrivateFieldSet3(this, _PartialDelegationIdentity_delegation, delegation, "f");
      }
      /**
       * The Delegation Chain of this identity.
       */
      get delegation() {
        return __classPrivateFieldGet3(this, _PartialDelegationIdentity_delegation, "f");
      }
      /**
       * Create a {@link PartialDelegationIdentity} from a {@link PublicKey} and a {@link DelegationChain}.
       * @param key The {@link PublicKey} to delegate to.
       * @param delegation a {@link DelegationChain} targeting the inner key.
       * @constructs PartialDelegationIdentity
       */
      static fromDelegation(key, delegation) {
        return new _PartialDelegationIdentity(key, delegation);
      }
    };
    _PartialDelegationIdentity_delegation = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/@dfinity/identity/lib/esm/identity/webauthn.js
var import_borc, PubKeyCoseAlgo;
var init_webauthn = __esm({
  "node_modules/@dfinity/identity/lib/esm/identity/webauthn.js"() {
    init_esm3();
    import_borc = __toESM(require_src());
    init_utils();
    init_esm2();
    (function(PubKeyCoseAlgo2) {
      PubKeyCoseAlgo2[PubKeyCoseAlgo2["ECDSA_WITH_SHA256"] = -7] = "ECDSA_WITH_SHA256";
    })(PubKeyCoseAlgo || (PubKeyCoseAlgo = {}));
  }
});

// node_modules/@dfinity/identity/lib/esm/index.js
var init_esm4 = __esm({
  "node_modules/@dfinity/identity/lib/esm/index.js"() {
    init_ed255192();
    init_ecdsa();
    init_delegation();
    init_partial();
    init_webauthn();
    init_esm3();
  }
});

// node_modules/@dfinity/auth-client/lib/esm/idleManager.js
var events, IdleManager;
var init_idleManager = __esm({
  "node_modules/@dfinity/auth-client/lib/esm/idleManager.js"() {
    events = ["mousedown", "mousemove", "keydown", "touchstart", "wheel"];
    IdleManager = class {
      /**
       * @protected
       * @param options {@link IdleManagerOptions}
       */
      constructor(options = {}) {
        var _a;
        this.callbacks = [];
        this.idleTimeout = 10 * 60 * 1e3;
        this.timeoutID = void 0;
        const { onIdle, idleTimeout = 10 * 60 * 1e3 } = options || {};
        this.callbacks = onIdle ? [onIdle] : [];
        this.idleTimeout = idleTimeout;
        const _resetTimer = this._resetTimer.bind(this);
        window.addEventListener("load", _resetTimer, true);
        events.forEach(function(name) {
          document.addEventListener(name, _resetTimer, true);
        });
        const debounce = (func, wait) => {
          let timeout;
          return (...args) => {
            const context = this;
            const later = function() {
              timeout = void 0;
              func.apply(context, args);
            };
            clearTimeout(timeout);
            timeout = window.setTimeout(later, wait);
          };
        };
        if (options === null || options === void 0 ? void 0 : options.captureScroll) {
          const scroll = debounce(_resetTimer, (_a = options === null || options === void 0 ? void 0 : options.scrollDebounce) !== null && _a !== void 0 ? _a : 100);
          window.addEventListener("scroll", scroll, true);
        }
        _resetTimer();
      }
      /**
       * Creates an {@link IdleManager}
       * @param {IdleManagerOptions} options Optional configuration
       * @see {@link IdleManagerOptions}
       * @param options.onIdle Callback once user has been idle. Use to prompt for fresh login, and use `Actor.agentOf(your_actor).invalidateIdentity()` to protect the user
       * @param options.idleTimeout timeout in ms
       * @param options.captureScroll capture scroll events
       * @param options.scrollDebounce scroll debounce time in ms
       */
      static create(options = {}) {
        return new this(options);
      }
      /**
       * @param {IdleCB} callback function to be called when user goes idle
       */
      registerCallback(callback) {
        this.callbacks.push(callback);
      }
      /**
       * Cleans up the idle manager and its listeners
       */
      exit() {
        clearTimeout(this.timeoutID);
        window.removeEventListener("load", this._resetTimer, true);
        const _resetTimer = this._resetTimer.bind(this);
        events.forEach(function(name) {
          document.removeEventListener(name, _resetTimer, true);
        });
        this.callbacks.forEach((cb) => cb());
      }
      /**
       * Resets the timeouts during cleanup
       */
      _resetTimer() {
        const exit = this.exit.bind(this);
        window.clearTimeout(this.timeoutID);
        this.timeoutID = window.setTimeout(exit, this.idleTimeout);
      }
    };
  }
});

// node_modules/idb/build/wrap-idb-value.js
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
function promisifyRequest(request) {
  const promise = new Promise((resolve, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error);
    };
    const success = () => {
      resolve(wrap(request.result));
      unlisten();
    };
    const error = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error);
  });
  promise.then((value2) => {
    if (value2 instanceof IDBCursor) {
      cursorRequestMap.set(value2, request);
    }
  }).catch(() => {
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error);
      tx.removeEventListener("abort", error);
    };
    const complete = () => {
      resolve();
      unlisten();
    };
    const error = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error);
    tx.addEventListener("abort", error);
  });
  transactionDoneMap.set(tx, done);
}
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
    return function(storeNames, ...args) {
      const tx = func.call(unwrap(this), storeNames, ...args);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap(tx);
    };
  }
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args) {
      func.apply(unwrap(this), args);
      return wrap(cursorRequestMap.get(this));
    };
  }
  return function(...args) {
    return wrap(func.apply(unwrap(this), args));
  };
}
function transformCachableValue(value2) {
  if (typeof value2 === "function")
    return wrapFunction(value2);
  if (value2 instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value2);
  if (instanceOfAny(value2, getIdbProxyableTypes()))
    return new Proxy(value2, idbProxyTraps);
  return value2;
}
function wrap(value2) {
  if (value2 instanceof IDBRequest)
    return promisifyRequest(value2);
  if (transformCache.has(value2))
    return transformCache.get(value2);
  const newValue = transformCachableValue(value2);
  if (newValue !== value2) {
    transformCache.set(value2, newValue);
    reverseTransformCache.set(newValue, value2);
  }
  return newValue;
}
var instanceOfAny, idbProxyableTypes, cursorAdvanceMethods, cursorRequestMap, transactionDoneMap, transactionStoreNamesMap, transformCache, reverseTransformCache, idbProxyTraps, unwrap;
var init_wrap_idb_value = __esm({
  "node_modules/idb/build/wrap-idb-value.js"() {
    instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);
    cursorRequestMap = /* @__PURE__ */ new WeakMap();
    transactionDoneMap = /* @__PURE__ */ new WeakMap();
    transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();
    transformCache = /* @__PURE__ */ new WeakMap();
    reverseTransformCache = /* @__PURE__ */ new WeakMap();
    idbProxyTraps = {
      get(target, prop, receiver) {
        if (target instanceof IDBTransaction) {
          if (prop === "done")
            return transactionDoneMap.get(target);
          if (prop === "objectStoreNames") {
            return target.objectStoreNames || transactionStoreNamesMap.get(target);
          }
          if (prop === "store") {
            return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
          }
        }
        return wrap(target[prop]);
      },
      set(target, prop, value2) {
        target[prop] = value2;
        return true;
      },
      has(target, prop) {
        if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
          return true;
        }
        return prop in target;
      }
    };
    unwrap = (value2) => reverseTransformCache.get(value2);
  }
});

// node_modules/idb/build/index.js
function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name, version);
  const openPromise = wrap(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
    });
  }
  if (blocked) {
    request.addEventListener("blocked", (event) => blocked(
      // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
      event.oldVersion,
      event.newVersion,
      event
    ));
  }
  openPromise.then((db) => {
    if (terminated)
      db.addEventListener("close", () => terminated());
    if (blocking) {
      db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
    }
  }).catch(() => {
  });
  return openPromise;
}
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
  ) {
    return;
  }
  const method = async function(storeName, ...args) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args.shift());
    return (await Promise.all([
      target2[targetFuncName](...args),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
var readMethods, writeMethods, cachedMethods;
var init_build = __esm({
  "node_modules/idb/build/index.js"() {
    init_wrap_idb_value();
    init_wrap_idb_value();
    readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
    writeMethods = ["put", "add", "delete", "clear"];
    cachedMethods = /* @__PURE__ */ new Map();
    replaceTraps((oldTraps) => ({
      ...oldTraps,
      get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
      has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
    }));
  }
});

// node_modules/@dfinity/auth-client/lib/esm/db.js
async function _getValue(db, storeName, key) {
  return await db.get(storeName, key);
}
async function _setValue(db, storeName, key, value2) {
  return await db.put(storeName, value2, key);
}
async function _removeValue(db, storeName, key) {
  return await db.delete(storeName, key);
}
var AUTH_DB_NAME, OBJECT_STORE_NAME, _openDbStore, IdbKeyVal;
var init_db = __esm({
  "node_modules/@dfinity/auth-client/lib/esm/db.js"() {
    init_build();
    init_storage();
    AUTH_DB_NAME = "auth-client-db";
    OBJECT_STORE_NAME = "ic-keyval";
    _openDbStore = async (dbName = AUTH_DB_NAME, storeName = OBJECT_STORE_NAME, version) => {
      if (isBrowser && (localStorage === null || localStorage === void 0 ? void 0 : localStorage.getItem(KEY_STORAGE_DELEGATION))) {
        localStorage.removeItem(KEY_STORAGE_DELEGATION);
        localStorage.removeItem(KEY_STORAGE_KEY);
      }
      return await openDB(dbName, version, {
        upgrade: (database) => {
          database.objectStoreNames;
          if (database.objectStoreNames.contains(storeName)) {
            database.clear(storeName);
          }
          database.createObjectStore(storeName);
        }
      });
    };
    IdbKeyVal = class _IdbKeyVal {
      // Do not use - instead prefer create
      constructor(_db, _storeName) {
        this._db = _db;
        this._storeName = _storeName;
      }
      /**
       * @param {DBCreateOptions} options - DBCreateOptions
       * @param {DBCreateOptions['dbName']} options.dbName name for the indexeddb database
       * @default
       * @param {DBCreateOptions['storeName']} options.storeName name for the indexeddb Data Store
       * @default
       * @param {DBCreateOptions['version']} options.version version of the database. Increment to safely upgrade
       * @constructs an {@link IdbKeyVal}
       */
      static async create(options) {
        const { dbName = AUTH_DB_NAME, storeName = OBJECT_STORE_NAME, version = DB_VERSION } = options !== null && options !== void 0 ? options : {};
        const db = await _openDbStore(dbName, storeName, version);
        return new _IdbKeyVal(db, storeName);
      }
      /**
       * Basic setter
       * @param {IDBValidKey} key string | number | Date | BufferSource | IDBValidKey[]
       * @param value value to set
       * @returns void
       */
      async set(key, value2) {
        return await _setValue(this._db, this._storeName, key, value2);
      }
      /**
       * Basic getter
       * Pass in a type T for type safety if you know the type the value will have if it is found
       * @param {IDBValidKey} key string | number | Date | BufferSource | IDBValidKey[]
       * @returns `Promise<T | null>`
       * @example
       * await get<string>('exampleKey') -> 'exampleValue'
       */
      async get(key) {
        var _a;
        return (_a = await _getValue(this._db, this._storeName, key)) !== null && _a !== void 0 ? _a : null;
      }
      /**
       * Remove a key
       * @param key {@link IDBValidKey}
       * @returns void
       */
      async remove(key) {
        return await _removeValue(this._db, this._storeName, key);
      }
    };
  }
});

// node_modules/@dfinity/auth-client/lib/esm/storage.js
var __classPrivateFieldSet4, __classPrivateFieldGet4, _IdbStorage_options, KEY_STORAGE_KEY, KEY_STORAGE_DELEGATION, KEY_VECTOR, DB_VERSION, isBrowser, LocalStorage, IdbStorage;
var init_storage = __esm({
  "node_modules/@dfinity/auth-client/lib/esm/storage.js"() {
    init_db();
    __classPrivateFieldSet4 = function(receiver, state, value2, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
    };
    __classPrivateFieldGet4 = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    KEY_STORAGE_KEY = "identity";
    KEY_STORAGE_DELEGATION = "delegation";
    KEY_VECTOR = "iv";
    DB_VERSION = 1;
    isBrowser = typeof window !== "undefined";
    LocalStorage = class {
      constructor(prefix = "ic-", _localStorage) {
        this.prefix = prefix;
        this._localStorage = _localStorage;
      }
      get(key) {
        return Promise.resolve(this._getLocalStorage().getItem(this.prefix + key));
      }
      set(key, value2) {
        this._getLocalStorage().setItem(this.prefix + key, value2);
        return Promise.resolve();
      }
      remove(key) {
        this._getLocalStorage().removeItem(this.prefix + key);
        return Promise.resolve();
      }
      _getLocalStorage() {
        if (this._localStorage) {
          return this._localStorage;
        }
        const ls = typeof window === "undefined" ? typeof globalThis === "undefined" ? typeof self === "undefined" ? void 0 : self.localStorage : globalThis.localStorage : window.localStorage;
        if (!ls) {
          throw new Error("Could not find local storage.");
        }
        return ls;
      }
    };
    IdbStorage = class {
      /**
       * @param options - DBCreateOptions
       * @param options.dbName - name for the indexeddb database
       * @param options.storeName - name for the indexeddb Data Store
       * @param options.version - version of the database. Increment to safely upgrade
       * @constructs an {@link IdbStorage}
       * @example
       * ```typescript
       * const storage = new IdbStorage({ dbName: 'my-db', storeName: 'my-store', version: 2 });
       * ```
       */
      constructor(options) {
        _IdbStorage_options.set(this, void 0);
        __classPrivateFieldSet4(this, _IdbStorage_options, options !== null && options !== void 0 ? options : {}, "f");
      }
      get _db() {
        return new Promise((resolve) => {
          if (this.initializedDb) {
            resolve(this.initializedDb);
            return;
          }
          IdbKeyVal.create(__classPrivateFieldGet4(this, _IdbStorage_options, "f")).then((db) => {
            this.initializedDb = db;
            resolve(db);
          });
        });
      }
      async get(key) {
        const db = await this._db;
        return await db.get(key);
      }
      async set(key, value2) {
        const db = await this._db;
        await db.set(key, value2);
      }
      async remove(key) {
        const db = await this._db;
        await db.remove(key);
      }
    };
    _IdbStorage_options = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/@dfinity/auth-client/lib/esm/index.js
var esm_exports4 = {};
__export(esm_exports4, {
  AuthClient: () => AuthClient,
  ERROR_USER_INTERRUPT: () => ERROR_USER_INTERRUPT,
  IdbKeyVal: () => IdbKeyVal,
  IdbStorage: () => IdbStorage,
  IdleManager: () => IdleManager,
  KEY_STORAGE_DELEGATION: () => KEY_STORAGE_DELEGATION,
  KEY_STORAGE_KEY: () => KEY_STORAGE_KEY,
  LocalStorage: () => LocalStorage
});
async function _deleteStorage(storage) {
  await storage.remove(KEY_STORAGE_KEY);
  await storage.remove(KEY_STORAGE_DELEGATION);
  await storage.remove(KEY_VECTOR);
}
var IDENTITY_PROVIDER_DEFAULT, IDENTITY_PROVIDER_ENDPOINT, ECDSA_KEY_LABEL, ED25519_KEY_LABEL, INTERRUPT_CHECK_INTERVAL, ERROR_USER_INTERRUPT, AuthClient;
var init_esm5 = __esm({
  "node_modules/@dfinity/auth-client/lib/esm/index.js"() {
    init_esm3();
    init_esm4();
    init_idleManager();
    init_storage();
    init_storage();
    init_db();
    init_idleManager();
    IDENTITY_PROVIDER_DEFAULT = "https://identity.ic0.app";
    IDENTITY_PROVIDER_ENDPOINT = "#authorize";
    ECDSA_KEY_LABEL = "ECDSA";
    ED25519_KEY_LABEL = "Ed25519";
    INTERRUPT_CHECK_INTERVAL = 500;
    ERROR_USER_INTERRUPT = "UserInterrupt";
    AuthClient = class {
      constructor(_identity, _key, _chain, _storage, idleManager, _createOptions, _idpWindow, _eventHandler) {
        this._identity = _identity;
        this._key = _key;
        this._chain = _chain;
        this._storage = _storage;
        this.idleManager = idleManager;
        this._createOptions = _createOptions;
        this._idpWindow = _idpWindow;
        this._eventHandler = _eventHandler;
        this._registerDefaultIdleCallback();
      }
      /**
       * Create an AuthClient to manage authentication and identity
       * @constructs
       * @param {AuthClientCreateOptions} options - Options for creating an {@link AuthClient}
       * @see {@link AuthClientCreateOptions}
       * @param options.identity Optional Identity to use as the base
       * @see {@link SignIdentity}
       * @param options.storage Storage mechanism for delegration credentials
       * @see {@link AuthClientStorage}
       * @param options.keyType Type of key to use for the base key
       * @param {IdleOptions} options.idleOptions Configures an {@link IdleManager}
       * @see {@link IdleOptions}
       * Default behavior is to clear stored identity and reload the page when a user goes idle, unless you set the disableDefaultIdleCallback flag or pass in a custom idle callback.
       * @example
       * const authClient = await AuthClient.create({
       *   idleOptions: {
       *     disableIdle: true
       *   }
       * })
       */
      static async create(options = {}) {
        var _a, _b, _c;
        const storage = (_a = options.storage) !== null && _a !== void 0 ? _a : new IdbStorage();
        const keyType = (_b = options.keyType) !== null && _b !== void 0 ? _b : ECDSA_KEY_LABEL;
        let key = null;
        if (options.identity) {
          key = options.identity;
        } else {
          let maybeIdentityStorage = await storage.get(KEY_STORAGE_KEY);
          if (!maybeIdentityStorage && isBrowser) {
            try {
              const fallbackLocalStorage = new LocalStorage();
              const localChain = await fallbackLocalStorage.get(KEY_STORAGE_DELEGATION);
              const localKey = await fallbackLocalStorage.get(KEY_STORAGE_KEY);
              if (localChain && localKey && keyType === ECDSA_KEY_LABEL) {
                console.log("Discovered an identity stored in localstorage. Migrating to IndexedDB");
                await storage.set(KEY_STORAGE_DELEGATION, localChain);
                await storage.set(KEY_STORAGE_KEY, localKey);
                maybeIdentityStorage = localChain;
                await fallbackLocalStorage.remove(KEY_STORAGE_DELEGATION);
                await fallbackLocalStorage.remove(KEY_STORAGE_KEY);
              }
            } catch (error) {
              console.error("error while attempting to recover localstorage: " + error);
            }
          }
          if (maybeIdentityStorage) {
            try {
              if (typeof maybeIdentityStorage === "object") {
                if (keyType === ED25519_KEY_LABEL && typeof maybeIdentityStorage === "string") {
                  key = await Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);
                } else {
                  key = await ECDSAKeyIdentity.fromKeyPair(maybeIdentityStorage);
                }
              } else if (typeof maybeIdentityStorage === "string") {
                key = Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);
              }
            } catch (e) {
            }
          }
        }
        let identity2 = new AnonymousIdentity();
        let chain = null;
        if (key) {
          try {
            const chainStorage = await storage.get(KEY_STORAGE_DELEGATION);
            if (typeof chainStorage === "object" && chainStorage !== null) {
              throw new Error("Delegation chain is incorrectly stored. A delegation chain should be stored as a string.");
            }
            if (options.identity) {
              identity2 = options.identity;
            } else if (chainStorage) {
              chain = DelegationChain.fromJSON(chainStorage);
              if (!isDelegationValid(chain)) {
                await _deleteStorage(storage);
                key = null;
              } else {
                if ("toDer" in key) {
                  identity2 = PartialDelegationIdentity.fromDelegation(key, chain);
                } else {
                  identity2 = DelegationIdentity.fromDelegation(key, chain);
                }
              }
            }
          } catch (e) {
            console.error(e);
            await _deleteStorage(storage);
            key = null;
          }
        }
        let idleManager = void 0;
        if ((_c = options.idleOptions) === null || _c === void 0 ? void 0 : _c.disableIdle) {
          idleManager = void 0;
        } else if (chain || options.identity) {
          idleManager = IdleManager.create(options.idleOptions);
        }
        if (!key) {
          if (keyType === ED25519_KEY_LABEL) {
            key = await Ed25519KeyIdentity.generate();
            await storage.set(KEY_STORAGE_KEY, JSON.stringify(key.toJSON()));
          } else {
            if (options.storage && keyType === ECDSA_KEY_LABEL) {
              console.warn(`You are using a custom storage provider that may not support CryptoKey storage. If you are using a custom storage provider that does not support CryptoKey storage, you should use '${ED25519_KEY_LABEL}' as the key type, as it can serialize to a string`);
            }
            key = await ECDSAKeyIdentity.generate();
            await storage.set(KEY_STORAGE_KEY, key.getKeyPair());
          }
        }
        return new this(identity2, key, chain, storage, idleManager, options);
      }
      _registerDefaultIdleCallback() {
        var _a, _b;
        const idleOptions = (_a = this._createOptions) === null || _a === void 0 ? void 0 : _a.idleOptions;
        if (!(idleOptions === null || idleOptions === void 0 ? void 0 : idleOptions.onIdle) && !(idleOptions === null || idleOptions === void 0 ? void 0 : idleOptions.disableDefaultIdleCallback)) {
          (_b = this.idleManager) === null || _b === void 0 ? void 0 : _b.registerCallback(() => {
            this.logout();
            location.reload();
          });
        }
      }
      async _handleSuccess(message, onSuccess) {
        var _a, _b;
        const delegations = message.delegations.map((signedDelegation) => {
          return {
            delegation: new Delegation(signedDelegation.delegation.pubkey, signedDelegation.delegation.expiration, signedDelegation.delegation.targets),
            signature: signedDelegation.signature.buffer
          };
        });
        const delegationChain = DelegationChain.fromDelegations(delegations, message.userPublicKey.buffer);
        const key = this._key;
        if (!key) {
          return;
        }
        this._chain = delegationChain;
        if ("toDer" in key) {
          this._identity = PartialDelegationIdentity.fromDelegation(key, this._chain);
        } else {
          this._identity = DelegationIdentity.fromDelegation(key, this._chain);
        }
        (_a = this._idpWindow) === null || _a === void 0 ? void 0 : _a.close();
        const idleOptions = (_b = this._createOptions) === null || _b === void 0 ? void 0 : _b.idleOptions;
        if (!this.idleManager && !(idleOptions === null || idleOptions === void 0 ? void 0 : idleOptions.disableIdle)) {
          this.idleManager = IdleManager.create(idleOptions);
          this._registerDefaultIdleCallback();
        }
        this._removeEventListener();
        delete this._idpWindow;
        if (this._chain) {
          await this._storage.set(KEY_STORAGE_DELEGATION, JSON.stringify(this._chain.toJSON()));
        }
        onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(message);
      }
      getIdentity() {
        return this._identity;
      }
      async isAuthenticated() {
        return !this.getIdentity().getPrincipal().isAnonymous() && this._chain !== null;
      }
      /**
       * AuthClient Login -
       * Opens up a new window to authenticate with Internet Identity
       * @param {AuthClientLoginOptions} options - Options for logging in
       * @param options.identityProvider Identity provider
       * @param options.maxTimeToLive Expiration of the authentication in nanoseconds
       * @param options.allowPinAuthentication If present, indicates whether or not the Identity Provider should allow the user to authenticate and/or register using a temporary key/PIN identity. Authenticating dapps may want to prevent users from using Temporary keys/PIN identities because Temporary keys/PIN identities are less secure than Passkeys (webauthn credentials) and because Temporary keys/PIN identities generally only live in a browser database (which may get cleared by the browser/OS).
       * @param options.derivationOrigin Origin for Identity Provider to use while generating the delegated identity
       * @param options.windowOpenerFeatures Configures the opened authentication window
       * @param options.onSuccess Callback once login has completed
       * @param options.onError Callback in case authentication fails
       * @example
       * const authClient = await AuthClient.create();
       * authClient.login({
       *  identityProvider: 'http://<canisterID>.127.0.0.1:8000',
       *  maxTimeToLive: BigInt (7) * BigInt(24) * BigInt(3_600_000_000_000), // 1 week
       *  windowOpenerFeatures: "toolbar=0,location=0,menubar=0,width=500,height=500,left=100,top=100",
       *  onSuccess: () => {
       *    console.log('Login Successful!');
       *  },
       *  onError: (error) => {
       *    console.error('Login Failed: ', error);
       *  }
       * });
       */
      async login(options) {
        var _a, _b, _c, _d;
        const defaultTimeToLive = (
          /* hours */
          BigInt(8) * /* nanoseconds */
          BigInt(36e11)
        );
        const identityProviderUrl = new URL(((_a = options === null || options === void 0 ? void 0 : options.identityProvider) === null || _a === void 0 ? void 0 : _a.toString()) || IDENTITY_PROVIDER_DEFAULT);
        identityProviderUrl.hash = IDENTITY_PROVIDER_ENDPOINT;
        (_b = this._idpWindow) === null || _b === void 0 ? void 0 : _b.close();
        this._removeEventListener();
        this._eventHandler = this._getEventHandler(identityProviderUrl, Object.assign({ maxTimeToLive: (_c = options === null || options === void 0 ? void 0 : options.maxTimeToLive) !== null && _c !== void 0 ? _c : defaultTimeToLive }, options));
        window.addEventListener("message", this._eventHandler);
        this._idpWindow = (_d = window.open(identityProviderUrl.toString(), "idpWindow", options === null || options === void 0 ? void 0 : options.windowOpenerFeatures)) !== null && _d !== void 0 ? _d : void 0;
        const checkInterruption = () => {
          if (this._idpWindow) {
            if (this._idpWindow.closed) {
              this._handleFailure(ERROR_USER_INTERRUPT, options === null || options === void 0 ? void 0 : options.onError);
            } else {
              setTimeout(checkInterruption, INTERRUPT_CHECK_INTERVAL);
            }
          }
        };
        checkInterruption();
      }
      _getEventHandler(identityProviderUrl, options) {
        return async (event) => {
          var _a, _b, _c;
          if (event.origin !== identityProviderUrl.origin) {
            console.warn(`WARNING: expected origin '${identityProviderUrl.origin}', got '${event.origin}' (ignoring)`);
            return;
          }
          const message = event.data;
          switch (message.kind) {
            case "authorize-ready": {
              const request = Object.assign({ kind: "authorize-client", sessionPublicKey: new Uint8Array((_a = this._key) === null || _a === void 0 ? void 0 : _a.getPublicKey().toDer()), maxTimeToLive: options === null || options === void 0 ? void 0 : options.maxTimeToLive, allowPinAuthentication: options === null || options === void 0 ? void 0 : options.allowPinAuthentication, derivationOrigin: (_b = options === null || options === void 0 ? void 0 : options.derivationOrigin) === null || _b === void 0 ? void 0 : _b.toString() }, options === null || options === void 0 ? void 0 : options.customValues);
              (_c = this._idpWindow) === null || _c === void 0 ? void 0 : _c.postMessage(request, identityProviderUrl.origin);
              break;
            }
            case "authorize-client-success":
              try {
                await this._handleSuccess(message, options === null || options === void 0 ? void 0 : options.onSuccess);
              } catch (err) {
                this._handleFailure(err.message, options === null || options === void 0 ? void 0 : options.onError);
              }
              break;
            case "authorize-client-failure":
              this._handleFailure(message.text, options === null || options === void 0 ? void 0 : options.onError);
              break;
            default:
              break;
          }
        };
      }
      _handleFailure(errorMessage, onError) {
        var _a;
        (_a = this._idpWindow) === null || _a === void 0 ? void 0 : _a.close();
        onError === null || onError === void 0 ? void 0 : onError(errorMessage);
        this._removeEventListener();
        delete this._idpWindow;
      }
      _removeEventListener() {
        if (this._eventHandler) {
          window.removeEventListener("message", this._eventHandler);
        }
        this._eventHandler = void 0;
      }
      async logout(options = {}) {
        await _deleteStorage(this._storage);
        this._identity = new AnonymousIdentity();
        this._chain = null;
        if (options.returnTo) {
          try {
            window.history.pushState({}, "", options.returnTo);
          } catch (e) {
            window.location.href = options.returnTo;
          }
        }
      }
    };
  }
});

// node_modules/@ic-reactor/core/dist/classes/agent/index.js
var require_agent2 = __commonJS({
  "node_modules/@ic-reactor/core/dist/classes/agent/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value2) {
        return value2 instanceof P ? value2 : new P(function(resolve) {
          resolve(value2);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __rest2 = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentManager = void 0;
    var agent_1 = (init_esm3(), __toCommonJS(esm_exports3));
    var helper_1 = require_helper();
    var auth_client_1 = (init_esm5(), __toCommonJS(esm_exports4));
    var constants_1 = require_constants();
    var AgentManager = class {
      constructor(options) {
        var _a;
        this._auth = null;
        this._subscribers = [];
        this.initialAgentState = {
          initialized: false,
          initializing: false,
          error: void 0,
          network: "ic"
        };
        this.initialAuthState = {
          identity: null,
          authenticating: false,
          authenticated: false,
          error: void 0
        };
        this.updateAgentState = (newState, action) => {
          this.agentStore.setState((state) => Object.assign(Object.assign({}, state), newState), false, action);
        };
        this.updateAuthState = (newState, action) => {
          this.authStore.setState((state) => Object.assign(Object.assign({}, state), newState), false, action);
        };
        this.initializeAgent = () => __awaiter(this, void 0, void 0, function* () {
          const network = this.getNetwork();
          this.updateAgentState({
            initializing: true,
            error: void 0,
            network
          }, "initializing");
          if (network !== "ic") {
            try {
              yield this._agent.fetchRootKey();
            } catch (error) {
              this.updateAgentState({ error, initializing: false }, "error");
            }
          }
          this.updateAgentState({ initialized: true, initializing: false }, "initialized");
        });
        this.subscribeAgent = (callback, initialize = true) => {
          if (initialize) {
            callback(this._agent);
          }
          this._subscribers.push(callback);
          return () => this.unsubscribeAgent(callback);
        };
        this.unsubscribeAgent = (callback) => {
          this._subscribers = this._subscribers.filter((sub) => sub !== callback);
        };
        this.notifySubscribers = () => __awaiter(this, void 0, void 0, function* () {
          yield Promise.all(this._subscribers.map((callback) => __awaiter(this, void 0, void 0, function* () {
            return callback(this._agent);
          })));
        });
        this.updateAgent = (options2) => __awaiter(this, void 0, void 0, function* () {
          const { agent } = options2 || {};
          if (agent) {
            this._agent = agent;
          } else if (options2) {
            this._agent = new agent_1.HttpAgent(options2);
            yield this.initializeAgent();
          }
          yield this.notifySubscribers();
        });
        this.authenticate = () => __awaiter(this, void 0, void 0, function* () {
          console.log(`Authenticating on ${this.getNetwork()} network`);
          this.updateAuthState({ authenticating: true }, "authenticating");
          try {
            this._auth = yield auth_client_1.AuthClient.create();
            const authenticated = yield this._auth.isAuthenticated();
            const identity2 = this._auth.getIdentity();
            this._agent.replaceIdentity(identity2);
            this.notifySubscribers();
            this.updateAuthState({
              authenticated,
              identity: identity2,
              authenticating: false
            }, "authenticated");
            return identity2;
          } catch (error) {
            this.updateAuthState({ error, authenticating: false }, "error");
            throw error;
          }
        });
        this.login = (options2) => __awaiter(this, void 0, void 0, function* () {
          this.updateAuthState({ authenticating: true }, "login");
          if (!this._auth) {
            yield this.authenticate();
          }
          if (!this._auth) {
            throw new Error("Auth client not initialized");
          }
          yield this._auth.login(Object.assign(Object.assign({ identityProvider: this.getIsLocal() ? constants_1.LOCAL_INTERNET_IDENTITY_PROVIDER : constants_1.IC_INTERNET_IDENTITY_PROVIDER }, options2), { onSuccess: (msg) => __awaiter(this, void 0, void 0, function* () {
            var _c;
            yield this.authenticate();
            (_c = options2 === null || options2 === void 0 ? void 0 : options2.onSuccess) === null || _c === void 0 ? void 0 : _c.call(options2, msg);
          }) }));
        });
        this.logout = (options2) => __awaiter(this, void 0, void 0, function* () {
          if (!this._auth) {
            throw new Error("Auth client not initialized");
          }
          yield this._auth.logout(options2);
          yield this.authenticate();
        });
        this.getAgent = () => {
          return this._agent;
        };
        this.getAgentHost = () => {
          return this._agent._host;
        };
        this.getIsLocal = () => {
          return this.getNetwork() !== "ic";
        };
        this.getNetwork = () => {
          const hostname = this.getAgentHost().hostname;
          if (constants_1.LOCAL_HOSTS.some((host) => hostname.endsWith(host))) {
            return "local";
          } else if (constants_1.REMOTE_HOSTS.some((host) => hostname.endsWith(host))) {
            return "remote";
          } else {
            return "ic";
          }
        };
        this.getAgentState = () => {
          return this.agentStore.getState();
        };
        this.subscribeAgentState = (listener) => {
          return this.agentStore.subscribe(listener);
        };
        this.getAuthState = () => {
          return this.authStore.getState();
        };
        this.subscribeAuthState = (listener) => {
          return this.authStore.subscribe(listener);
        };
        this.getAuth = () => {
          return this._auth;
        };
        this.getIdentity = () => {
          return this.authStore.getState().identity;
        };
        this.getPrincipal = () => {
          const identity2 = this.authStore.getState().identity;
          return identity2 ? identity2.getPrincipal() : null;
        };
        const _b = options || {}, { withDevtools, port = 4943, withLocalEnv, withProcessEnv } = _b, agentOptions = __rest2(_b, ["withDevtools", "port", "withLocalEnv", "withProcessEnv"]);
        if (withProcessEnv) {
          const processNetwork = (0, helper_1.getProcessEnvNetwork)();
          agentOptions.host = processNetwork === "ic" ? constants_1.IC_HOST_NETWORK_URI : void 0;
        } else if (withLocalEnv) {
          agentOptions.host = `http://127.0.0.1:${port}`;
        } else {
          agentOptions.host = (_a = agentOptions.host) !== null && _a !== void 0 ? _a : constants_1.IC_HOST_NETWORK_URI;
        }
        this.agentStore = (0, helper_1.createStoreWithOptionalDevtools)(this.initialAgentState, {
          withDevtools,
          name: "reactor-agent",
          store: "agent"
        });
        this.authStore = (0, helper_1.createStoreWithOptionalDevtools)(this.initialAuthState, {
          withDevtools,
          name: "reactor-agent",
          store: "auth"
        });
        this._agent = new agent_1.HttpAgent(agentOptions);
        this.initializeAgent();
      }
    };
    exports.AgentManager = AgentManager;
  }
});

// node_modules/@ic-reactor/core/dist/createAgentManager.js
var require_createAgentManager = __commonJS({
  "node_modules/@ic-reactor/core/dist/createAgentManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createAgentManager = void 0;
    var agent_1 = require_agent2();
    var createAgentManager = (config) => {
      return new agent_1.AgentManager(config);
    };
    exports.createAgentManager = createAgentManager;
  }
});

// node_modules/@ic-reactor/core/dist/createReactorStore.js
var require_createReactorStore = __commonJS({
  "node_modules/@ic-reactor/core/dist/createReactorStore.js"(exports) {
    "use strict";
    var __rest2 = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createReactorStore = void 0;
    var createActorManager_1 = require_createActorManager();
    var createAgentManager_1 = require_createAgentManager();
    var createReactorStore = (config) => {
      const { idlFactory, canisterId, withDevtools = false, initializeOnCreate = true, withVisitor = false, agentManager: maybeAgentManager } = config, agentParameters = __rest2(config, ["idlFactory", "canisterId", "withDevtools", "initializeOnCreate", "withVisitor", "agentManager"]);
      const agentManager = maybeAgentManager || (0, createAgentManager_1.createAgentManager)(Object.assign({ withDevtools }, agentParameters));
      const actorManager = (0, createActorManager_1.createActorManager)({
        idlFactory,
        canisterId,
        agentManager,
        withVisitor,
        withDevtools,
        initializeOnCreate
      });
      return actorManager;
    };
    exports.createReactorStore = createReactorStore;
  }
});

// node_modules/@ic-reactor/core/dist/createReactorCore.js
var require_createReactorCore = __commonJS({
  "node_modules/@ic-reactor/core/dist/createReactorCore.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value2) {
        return value2 instanceof P ? value2 : new P(function(resolve) {
          resolve(value2);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __rest2 = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createReactorCore = void 0;
    var createReactorStore_1 = require_createReactorStore();
    var utils_1 = require_utils();
    var createReactorCore = (config) => {
      const _a = (0, createReactorStore_1.createReactorStore)(config), { subscribeActorState, updateMethodState, callMethodWithOptions, callMethod, getState, agentManager } = _a, rest = __rest2(_a, ["subscribeActorState", "updateMethodState", "callMethodWithOptions", "callMethod", "getState", "agentManager"]);
      const actorMethod = (functionName, args, options = {}) => {
        const requestHash = (0, utils_1.generateRequestHash)(args);
        const updateState = (newState = {}) => {
          updateMethodState(functionName, requestHash, newState);
        };
        updateState();
        try {
          const methodState = (key) => {
            const state = getState().methodState[functionName][requestHash];
            switch (key) {
              case "data":
                return state.data;
              case "loading":
                return state.loading;
              case "error":
                return state.error;
              default:
                return state;
            }
          };
          const subscribe = (callback) => {
            callback(methodState());
            const unsubscribe = subscribeActorState((state) => {
              const methodState2 = state.methodState[functionName];
              const methodStateHash = methodState2[requestHash];
              if (methodStateHash) {
                callback(methodStateHash);
              }
            });
            return unsubscribe;
          };
          const call = (replaceArgs) => __awaiter(void 0, void 0, void 0, function* () {
            updateState({
              loading: true,
              error: void 0
            });
            try {
              const data = yield callMethodWithOptions(options)(functionName, ...replaceArgs !== null && replaceArgs !== void 0 ? replaceArgs : args);
              updateState({ data, loading: false });
              return data;
            } catch (error) {
              updateState({
                error,
                loading: false
              });
              throw error;
            }
          });
          return {
            requestHash,
            subscribe,
            getState: methodState,
            call
          };
        } catch (error) {
          updateState({
            error,
            loading: false
          });
          throw error;
        }
      };
      const queryCall = (_a2) => {
        var { functionName, args = [], refetchOnMount = true, refetchInterval = false } = _a2, options = __rest2(_a2, ["functionName", "args", "refetchOnMount", "refetchInterval"]);
        let intervalId = null;
        const _b = actorMethod(functionName, args, options), { call } = _b, rest2 = __rest2(_b, ["call"]);
        if (refetchInterval) {
          intervalId = setInterval(() => {
            call();
          }, refetchInterval);
        }
        const clearRefetchInterval = () => {
          if (intervalId) {
            clearInterval(intervalId);
          }
        };
        let dataPromise = Promise.resolve();
        if (refetchOnMount)
          dataPromise = call();
        return Object.assign(Object.assign({}, rest2), { call, dataPromise, intervalId, clearRefetchInterval });
      };
      const updateCall = (_a2) => {
        var { functionName, args = [] } = _a2, options = __rest2(_a2, ["functionName", "args"]);
        return actorMethod(functionName, args, options);
      };
      return Object.assign(Object.assign({
        getState,
        queryCall,
        updateCall,
        callMethod,
        callMethodWithOptions,
        subscribeActorState
      }, agentManager), rest);
    };
    exports.createReactorCore = createReactorCore;
  }
});

// node_modules/@ic-reactor/core/dist/classes/adapter/index.js
var require_adapter = __commonJS({
  "node_modules/@ic-reactor/core/dist/classes/adapter/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value2) {
        return value2 instanceof P ? value2 : new P(function(resolve) {
          resolve(value2);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CandidAdapter = void 0;
    var agent_1 = (init_esm3(), __toCommonJS(esm_exports3));
    var constants_1 = require_constants();
    var utils_1 = require_utils();
    var CandidAdapter = class {
      constructor({ agentManager, agent, didjsCanisterId }) {
        this.unsubscribeAgent = () => {
        };
        if (agent) {
          this.agent = agent;
        } else if (agentManager) {
          this.agent = agentManager.getAgent();
          this.unsubscribeAgent = agentManager.subscribeAgent((agent2) => {
            this.agent = agent2;
            this.didjsCanisterId = didjsCanisterId || this.getDefaultDidJsId();
          });
        } else {
          throw new Error("No agent or agentManager provided");
        }
        this.didjsCanisterId = didjsCanisterId || this.getDefaultDidJsId();
      }
      initializeParser(module2) {
        return __awaiter(this, void 0, void 0, function* () {
          if (module2 !== void 0) {
            this.parserModule = module2;
            return;
          }
          try {
            this.parserModule = __require("@ic-reactor/parser");
            if (typeof this.parserModule !== "undefined" && "default" in this.parserModule) {
              yield this.parserModule.default();
            }
          } catch (error) {
            throw new Error(`Error initializing parser: ${error}`);
          }
        });
      }
      getDefaultDidJsId() {
        var _a, _b;
        return ((_b = (_a = this.agent).isLocal) === null || _b === void 0 ? void 0 : _b.call(_a)) === true ? constants_1.DEFAULT_LOCAL_DIDJS_ID : constants_1.DEFAULT_IC_DIDJS_ID;
      }
      fetchCandidDefinition(canisterId) {
        return __awaiter(this, void 0, void 0, function* () {
          let candidDef = "";
          try {
            candidDef = yield this.getFromMetadata(canisterId);
            if (!candidDef) {
              throw new Error("Cannot retrieve Candid definition from metadata");
            }
          } catch (error) {
            candidDef = yield this.getFromTmpHack(canisterId).catch(() => {
              return void 0;
            });
          }
          if (!candidDef) {
            throw new Error("Failed to retrieve Candid definition by any method.");
          }
          return candidDef;
        });
      }
      getCandidDefinition(canisterId) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const candidDef = yield this.fetchCandidDefinition(canisterId);
            return this.dynamicEvalJs(candidDef);
          } catch (error) {
            throw new Error(`Error fetching canister ${canisterId}: ${error}`);
          }
        });
      }
      getFromMetadata(canisterId) {
        return __awaiter(this, void 0, void 0, function* () {
          const status = yield agent_1.CanisterStatus.request({
            agent: this.agent,
            canisterId,
            paths: ["candid"]
          });
          return status.get("candid");
        });
      }
      getFromTmpHack(canisterId) {
        return __awaiter(this, void 0, void 0, function* () {
          const commonInterface = ({ IDL }) => IDL.Service({
            __get_candid_interface_tmp_hack: IDL.Func([], [IDL.Text], ["query"])
          });
          const actor = agent_1.Actor.createActor(commonInterface, {
            agent: this.agent,
            canisterId
          });
          return yield actor.__get_candid_interface_tmp_hack();
        });
      }
      dynamicEvalJs(data) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            let candidDef = "";
            try {
              candidDef = this.parseDidToJs(data);
              if (candidDef === "") {
                throw new Error("Cannot compile Candid to JavaScript");
              }
            } catch (error) {
              candidDef = (yield this.fetchDidTojs(data))[0];
            }
            if (JSON.stringify(candidDef) === JSON.stringify([])) {
              throw new Error("Cannot compile Candid to JavaScript");
            }
            return yield (0, utils_1.importCandidDefinition)(candidDef);
          } catch (error) {
            throw new Error(`Error evaluating Candid definition: ${error}`);
          }
        });
      }
      fetchDidTojs(candidSource, didjsCanisterId) {
        return __awaiter(this, void 0, void 0, function* () {
          const didjsInterface = ({ IDL }) => IDL.Service({
            did_to_js: IDL.Func([IDL.Text], [IDL.Opt(IDL.Text)], ["query"])
          });
          const didjs = agent_1.Actor.createActor(didjsInterface, {
            agent: this.agent,
            canisterId: didjsCanisterId || this.didjsCanisterId
          });
          return didjs.did_to_js(candidSource);
        });
      }
      parseDidToJs(candidSource) {
        if (!this.parserModule) {
          throw new Error("Parser module not available");
        }
        return this.parserModule.didToJs(candidSource);
      }
    };
    exports.CandidAdapter = CandidAdapter;
  }
});

// node_modules/@ic-reactor/core/dist/createCandidAdapter.js
var require_createCandidAdapter = __commonJS({
  "node_modules/@ic-reactor/core/dist/createCandidAdapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCandidAdapter = void 0;
    var adapter_1 = require_adapter();
    var createCandidAdapter = (config) => {
      return new adapter_1.CandidAdapter(config);
    };
    exports.createCandidAdapter = createCandidAdapter;
  }
});

// node_modules/@ic-reactor/core/dist/classes/index.js
var require_classes = __commonJS({
  "node_modules/@ic-reactor/core/dist/classes/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_actor(), exports);
    __exportStar(require_agent2(), exports);
    __exportStar(require_adapter(), exports);
  }
});

// node_modules/@ic-reactor/core/dist/classes/agent/types.js
var require_types = __commonJS({
  "node_modules/@ic-reactor/core/dist/classes/agent/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@ic-reactor/core/dist/classes/actor/types.js
var require_types2 = __commonJS({
  "node_modules/@ic-reactor/core/dist/classes/actor/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@ic-reactor/core/dist/classes/adapter/types.js
var require_types3 = __commonJS({
  "node_modules/@ic-reactor/core/dist/classes/adapter/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@ic-reactor/core/dist/classes/types.js
var require_types4 = __commonJS({
  "node_modules/@ic-reactor/core/dist/classes/types.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_types(), exports);
    __exportStar(require_types2(), exports);
    __exportStar(require_types3(), exports);
  }
});

// node_modules/@ic-reactor/core/dist/types.js
var require_types5 = __commonJS({
  "node_modules/@ic-reactor/core/dist/types.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_types4(), exports);
  }
});

// node_modules/@ic-reactor/core/dist/index.js
var require_dist = __commonJS({
  "node_modules/@ic-reactor/core/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utils = exports.types = exports.classes = void 0;
    __exportStar(require_createReactorCore(), exports);
    __exportStar(require_createReactorStore(), exports);
    __exportStar(require_createCandidAdapter(), exports);
    __exportStar(require_createActorManager(), exports);
    __exportStar(require_createAgentManager(), exports);
    exports.classes = __importStar(require_classes());
    exports.types = __importStar(require_types5());
    exports.utils = __importStar(require_utils());
  }
});

// node_modules/zustand/esm/vanilla.mjs
var createStoreImpl2, createStore2;
var init_vanilla2 = __esm({
  "node_modules/zustand/esm/vanilla.mjs"() {
    createStoreImpl2 = (createState) => {
      let state;
      const listeners = /* @__PURE__ */ new Set();
      const setState = (partial, replace) => {
        const nextState = typeof partial === "function" ? partial(state) : partial;
        if (!Object.is(nextState, state)) {
          const previousState = state;
          state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
          listeners.forEach((listener) => listener(state, previousState));
        }
      };
      const getState = () => state;
      const getInitialState = () => initialState;
      const subscribe = (listener) => {
        listeners.add(listener);
        return () => listeners.delete(listener);
      };
      const destroy = () => {
        if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
          console.warn(
            "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
          );
        }
        listeners.clear();
      };
      const api = { setState, getState, getInitialState, subscribe, destroy };
      const initialState = state = createState(setState, getState, api);
      return api;
    };
    createStore2 = (createState) => createState ? createStoreImpl2(createState) : createStoreImpl2;
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React = require_react();
        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useState = React.useState, useEffect = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue2 = React.useDebugValue;
        var didWarnOld18Alpha = false;
        var didWarnUncachedGetSnapshot = false;
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          {
            if (!didWarnOld18Alpha) {
              if (React.startTransition !== void 0) {
                didWarnOld18Alpha = true;
                error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
              }
            }
          }
          var value2 = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedValue = getSnapshot();
              if (!objectIs(value2, cachedValue)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var _useState = useState({
            inst: {
              value: value2,
              getSnapshot
            }
          }), inst = _useState[0].inst, forceUpdate = _useState[1];
          useLayoutEffect(function() {
            inst.value = value2;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          }, [subscribe, value2, getSnapshot]);
          useEffect(function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            };
            return subscribe(handleStoreChange);
          }, [subscribe]);
          useDebugValue2(value2);
          return value2;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
          return getSnapshot();
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isServerEnvironment = !canUseDOM;
        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
        var useSyncExternalStore$2 = React.useSyncExternalStore !== void 0 ? React.useSyncExternalStore : shim;
        exports.useSyncExternalStore = useSyncExternalStore$2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
var require_with_selector_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React = require_react();
        var shim = require_shim();
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useSyncExternalStore = shim.useSyncExternalStore;
        var useRef2 = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue2 = React.useDebugValue;
        function useSyncExternalStoreWithSelector2(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
          var instRef = useRef2(null);
          var inst;
          if (instRef.current === null) {
            inst = {
              hasValue: false,
              value: null
            };
            instRef.current = inst;
          } else {
            inst = instRef.current;
          }
          var _useMemo = useMemo(function() {
            var hasMemo = false;
            var memoizedSnapshot;
            var memoizedSelection;
            var memoizedSelector = function(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                var _nextSelection = selector(nextSnapshot);
                if (isEqual !== void 0) {
                  if (inst.hasValue) {
                    var currentSelection = inst.value;
                    if (isEqual(currentSelection, _nextSelection)) {
                      memoizedSelection = currentSelection;
                      return currentSelection;
                    }
                  }
                }
                memoizedSelection = _nextSelection;
                return _nextSelection;
              }
              var prevSnapshot = memoizedSnapshot;
              var prevSelection = memoizedSelection;
              if (objectIs(prevSnapshot, nextSnapshot)) {
                return prevSelection;
              }
              var nextSelection = selector(nextSnapshot);
              if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {
                return prevSelection;
              }
              memoizedSnapshot = nextSnapshot;
              memoizedSelection = nextSelection;
              return nextSelection;
            };
            var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
            var getSnapshotWithSelector = function() {
              return memoizedSelector(getSnapshot());
            };
            var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            };
            return [getSnapshotWithSelector, getServerSnapshotWithSelector];
          }, [getSnapshot, getServerSnapshot, selector, isEqual]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];
          var value2 = useSyncExternalStore(subscribe, getSelection, getServerSelection);
          useEffect(function() {
            inst.hasValue = true;
            inst.value = value2;
          }, [value2]);
          useDebugValue2(value2);
          return value2;
        }
        exports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/use-sync-external-store/shim/with-selector.js
var require_with_selector = __commonJS({
  "node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_with_selector_development();
    }
  }
});

// node_modules/zustand/esm/index.js
var esm_exports5 = {};
__export(esm_exports5, {
  create: () => create,
  createStore: () => createStore2,
  default: () => react,
  useStore: () => useStore
});
function useStore(api, selector = identity, equalityFn) {
  if (equalityFn && !didWarnAboutEqualityFn) {
    console.warn(
      "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
    );
    didWarnAboutEqualityFn = true;
  }
  const slice = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getInitialState,
    selector,
    equalityFn
  );
  useDebugValue(slice);
  return slice;
}
var import_react, import_with_selector, useDebugValue, useSyncExternalStoreWithSelector, didWarnAboutEqualityFn, identity, createImpl, create, react;
var init_esm6 = __esm({
  "node_modules/zustand/esm/index.js"() {
    init_vanilla2();
    init_vanilla2();
    import_react = __toESM(require_react());
    import_with_selector = __toESM(require_with_selector());
    ({ useDebugValue } = import_react.default);
    ({ useSyncExternalStoreWithSelector } = import_with_selector.default);
    didWarnAboutEqualityFn = false;
    identity = (arg) => arg;
    createImpl = (createState) => {
      if (typeof createState !== "function") {
        console.warn(
          "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
        );
      }
      const api = typeof createState === "function" ? createStore2(createState) : createState;
      const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);
      Object.assign(useBoundStore, api);
      return useBoundStore;
    };
    create = (createState) => createState ? createImpl(createState) : createImpl;
    react = (createState) => {
      if (true) {
        console.warn(
          "[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`."
        );
      }
      return create(createState);
    };
  }
});

// node_modules/@ic-reactor/react/dist/helpers/agentHooks.js
var require_agentHooks = __commonJS({
  "node_modules/@ic-reactor/react/dist/helpers/agentHooks.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.agentHooks = void 0;
    var react_1 = __importDefault(require_react());
    var zustand_1 = (init_esm6(), __toCommonJS(esm_exports5));
    var agentHooks = (agentManager) => {
      const { agentStore, getAgent, subscribeAgent } = agentManager;
      const useAgentState = () => (0, zustand_1.useStore)(agentStore);
      const useAgent = () => {
        const [agent, setAgent] = react_1.default.useState(getAgent);
        react_1.default.useEffect(() => subscribeAgent(setAgent), [subscribeAgent]);
        return agent;
      };
      return {
        useAgent,
        useAgentState
      };
    };
    exports.agentHooks = agentHooks;
  }
});

// node_modules/zustand/esm/react/shallow.js
var shallow_exports = {};
__export(shallow_exports, {
  useShallow: () => useShallow
});
function shallow(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  if (objA instanceof Map && objB instanceof Map) {
    if (objA.size !== objB.size)
      return false;
    for (const [key, value2] of objA) {
      if (!Object.is(value2, objB.get(key))) {
        return false;
      }
    }
    return true;
  }
  if (objA instanceof Set && objB instanceof Set) {
    if (objA.size !== objB.size)
      return false;
    for (const value2 of objA) {
      if (!objB.has(value2)) {
        return false;
      }
    }
    return true;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (const keyA of keysA) {
    if (!Object.prototype.hasOwnProperty.call(objB, keyA) || !Object.is(objA[keyA], objB[keyA])) {
      return false;
    }
  }
  return true;
}
function useShallow(selector) {
  const prev = useRef();
  return (state) => {
    const next = selector(state);
    return shallow(prev.current, next) ? prev.current : prev.current = next;
  };
}
var import_react2, useRef;
var init_shallow = __esm({
  "node_modules/zustand/esm/react/shallow.js"() {
    import_react2 = __toESM(require_react());
    ({ useRef } = import_react2.default);
  }
});

// node_modules/@ic-reactor/react/dist/utils.js
var require_utils2 = __commonJS({
  "node_modules/@ic-reactor/react/dist/utils.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_utils(), exports);
  }
});

// node_modules/@ic-reactor/react/dist/helpers/actorHooks.js
var require_actorHooks = __commonJS({
  "node_modules/@ic-reactor/react/dist/helpers/actorHooks.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value2) {
        return value2 instanceof P ? value2 : new P(function(resolve) {
          resolve(value2);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __rest2 = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.actorHooks = void 0;
    var React = __importStar(require_react());
    var zustand_1 = (init_esm6(), __toCommonJS(esm_exports5));
    var shallow_1 = (init_shallow(), __toCommonJS(shallow_exports));
    var utils_1 = require_utils2();
    var DEFAULT_STATE = {
      data: void 0,
      error: void 0,
      loading: false
    };
    var actorHooks = (actorManager) => {
      const { actorStore, canisterId, visitFunction, methodAttributes, updateMethodState, extractMethodAttributes, extractInterface, callMethodWithOptions, initialize } = actorManager;
      const useActorStore = (selector = (s) => s) => {
        return (0, zustand_1.useStore)(actorStore, (0, shallow_1.useShallow)(selector));
      };
      const useActorState = () => {
        return useActorStore((state) => ({
          name: state.name,
          error: state.error,
          initialized: state.initialized,
          initializing: state.initializing,
          canisterId
        }));
      };
      const useMethodState = (functionName, requestKey) => {
        const state = useActorStore((state2) => {
          var _a;
          return (_a = state2.methodState[functionName]) === null || _a === void 0 ? void 0 : _a[requestKey];
        });
        const setSharedState = React.useCallback((newState) => {
          updateMethodState(functionName, requestKey, newState);
        }, [functionName, requestKey]);
        return [state, setSharedState];
      };
      const useMethodAttributes = () => {
        return React.useMemo(extractMethodAttributes, []);
      };
      const useMethodNames = () => {
        return React.useMemo(() => Object.keys(extractMethodAttributes()), []);
      };
      const useActorInterface = () => {
        return React.useMemo(() => extractInterface(), []);
      };
      const useVisitService = () => {
        return visitFunction;
      };
      const useVisitMethod = (functionName) => {
        return React.useMemo(() => {
          if (!visitFunction[functionName]) {
            throw new Error(`Method ${functionName} not found`);
          }
          return visitFunction[functionName];
        }, [functionName]);
      };
      const useSharedCall = (_a) => {
        var { args = [], functionName, throwOnError = false, onError, onLoading, onSuccess } = _a, options = __rest2(_a, ["args", "functionName", "throwOnError", "onError", "onLoading", "onSuccess"]);
        const requestKey = React.useMemo(() => (0, utils_1.generateRequestHash)(args), [args]);
        const [sharedState, setSharedState] = useMethodState(functionName, requestKey);
        const reset = React.useCallback(() => updateMethodState(functionName, requestKey, DEFAULT_STATE), [functionName, requestKey]);
        const call = React.useCallback((eventOrReplaceArgs) => __awaiter(void 0, void 0, void 0, function* () {
          setSharedState({ error: void 0, loading: true });
          onLoading === null || onLoading === void 0 ? void 0 : onLoading(true);
          try {
            const replaceArgs = eventOrReplaceArgs instanceof Array ? eventOrReplaceArgs : args;
            const data = yield callMethodWithOptions(options)(functionName, ...replaceArgs !== null && replaceArgs !== void 0 ? replaceArgs : args);
            setSharedState({ data, error: void 0, loading: false });
            onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(data);
            onLoading === null || onLoading === void 0 ? void 0 : onLoading(false);
            return data;
          } catch (error) {
            console.error("Error in call:", error);
            setSharedState({
              error,
              loading: false
            });
            onError === null || onError === void 0 ? void 0 : onError(error);
            onLoading === null || onLoading === void 0 ? void 0 : onLoading(false);
            if (throwOnError)
              throw error;
          }
        }), [args, functionName, options, onError, onLoading, onSuccess, throwOnError]);
        return Object.assign({ call, reset, requestKey }, sharedState);
      };
      const useQueryCall = (_a) => {
        var { refetchOnMount = true, refetchInterval = false } = _a, rest = __rest2(_a, ["refetchOnMount", "refetchInterval"]);
        const _b = useSharedCall(rest), { call } = _b, state = __rest2(_b, ["call"]);
        const intervalId = React.useRef();
        React.useEffect(() => {
          var _a2;
          if (refetchInterval) {
            intervalId.current = setInterval(call, refetchInterval);
          }
          if (refetchOnMount && state.data === void 0) {
            call();
          } else if (refetchOnMount && state.data !== void 0) {
            (_a2 = rest.onSuccess) === null || _a2 === void 0 ? void 0 : _a2.call(rest, state.data);
          }
          return () => clearInterval(intervalId.current);
        }, [refetchInterval, refetchOnMount]);
        return Object.assign({ call, intervalId }, state);
      };
      const useUpdateCall = useSharedCall;
      const useMethod = (params) => {
        const attributes = React.useMemo(() => {
          if (!methodAttributes[params.functionName]) {
            throw new Error(`Method ${params.functionName} not found`);
          }
          return methodAttributes[params.functionName];
        }, [params.functionName]);
        const visit = React.useCallback((extractorClass, data) => visitFunction[params.functionName](extractorClass, data), [params.functionName]);
        const validateArgs = React.useCallback((args, throwOnError = false) => {
          if (attributes.numberOfArgs > 0) {
            if (args === void 0 || args.length === 0) {
              if (throwOnError) {
                throw new Error(`Method ${params.functionName} requires ${attributes.numberOfArgs} arguments, but none were provided.`);
              }
              return false;
            }
            try {
              attributes.validate(args);
              return true;
            } catch (error) {
              if (throwOnError) {
                throw error;
              }
              return false;
            }
          }
          return true;
        }, [attributes]);
        let refetchOnMount = params.refetchOnMount;
        let refetchInterval = params.refetchInterval;
        let formRequired = true;
        switch (attributes.type) {
          case "query":
            if (validateArgs(params.args)) {
              formRequired = params.refetchOnMount === false ? true : false;
            } else {
              refetchOnMount = false;
              refetchInterval = false;
            }
            return Object.assign(Object.assign({
              visit,
              validateArgs
            }, useQueryCall(Object.assign(Object.assign({}, params), {
              refetchOnMount,
              refetchInterval
            }))), { formRequired });
          case "update":
            return Object.assign(Object.assign({ visit, validateArgs }, useUpdateCall(params)), { formRequired });
          default:
            throw new Error(`Method type ${attributes.type} not found`);
        }
      };
      return {
        initialize,
        useActorStore,
        useMethodAttributes,
        useMethodNames,
        useMethod,
        useQueryCall,
        useUpdateCall,
        useActorState,
        useVisitMethod,
        useVisitService,
        useActorInterface
      };
    };
    exports.actorHooks = actorHooks;
  }
});

// node_modules/@ic-reactor/react/dist/helpers/authHooks.js
var require_authHooks = __commonJS({
  "node_modules/@ic-reactor/react/dist/helpers/authHooks.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value2) {
        return value2 instanceof P ? value2 : new P(function(resolve) {
          resolve(value2);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.authHooks = void 0;
    var react_1 = __importDefault(require_react());
    var zustand_1 = (init_esm6(), __toCommonJS(esm_exports5));
    var utils_1 = require_utils();
    var authHooks = (agentManager) => {
      const { authenticate: authenticator, getIsLocal, getAuth, authStore } = agentManager;
      const useAuthState = () => (0, zustand_1.useStore)(authStore);
      const useUserPrincipal = () => {
        var _a, _b;
        return (_b = (_a = useAuthState()) === null || _a === void 0 ? void 0 : _a.identity) === null || _b === void 0 ? void 0 : _b.getPrincipal();
      };
      const useAuth = ({ onAuthentication, onAuthenticationSuccess, onAuthenticationFailure, onLogin, onLoginSuccess, onLoginError, onLoggedOut } = {}) => {
        const network = react_1.default.useRef("ic");
        const [loginState, setLoginState] = react_1.default.useState({
          loading: false,
          error: void 0
        });
        const { authenticated, authenticating, error, identity: identity2 } = useAuthState();
        const authenticate = react_1.default.useCallback(() => __awaiter(void 0, void 0, void 0, function* () {
          const authenticatePromise = new Promise((resolve, reject) => {
            authenticator().then((identity3) => {
              onAuthenticationSuccess === null || onAuthenticationSuccess === void 0 ? void 0 : onAuthenticationSuccess(identity3);
              resolve(identity3);
            }).catch((e) => {
              onAuthenticationFailure === null || onAuthenticationFailure === void 0 ? void 0 : onAuthenticationFailure(e);
              reject(e);
            });
          });
          onAuthentication === null || onAuthentication === void 0 ? void 0 : onAuthentication(() => authenticatePromise);
          return authenticatePromise;
        }), [
          authenticator,
          onAuthentication,
          onAuthenticationSuccess,
          onAuthenticationFailure
        ]);
        const login = react_1.default.useCallback((options) => __awaiter(void 0, void 0, void 0, function* () {
          setLoginState({ loading: true, error: void 0 });
          const loginPromise = new Promise((resolve, reject) => {
            try {
              const authClient = getAuth();
              if (!authClient) {
                throw new Error("Auth client not initialized");
              }
              authClient.login(Object.assign(Object.assign({ identityProvider: getIsLocal() ? utils_1.LOCAL_INTERNET_IDENTITY_PROVIDER : utils_1.IC_INTERNET_IDENTITY_PROVIDER }, options), { onSuccess: (msg) => {
                authenticate().then((identity3) => {
                  var _a;
                  const principal = identity3.getPrincipal();
                  (_a = options === null || options === void 0 ? void 0 : options.onSuccess) === null || _a === void 0 ? void 0 : _a.call(options, msg);
                  onLoginSuccess === null || onLoginSuccess === void 0 ? void 0 : onLoginSuccess(principal);
                  resolve(principal);
                  setLoginState({ loading: false, error: void 0 });
                }).catch((error2) => {
                  setLoginState({ loading: false, error: error2 });
                  onLoginError === null || onLoginError === void 0 ? void 0 : onLoginError(error2);
                  reject(error2);
                });
              }, onError: (error2) => {
                var _a;
                (_a = options === null || options === void 0 ? void 0 : options.onError) === null || _a === void 0 ? void 0 : _a.call(options, error2);
                setLoginState({ loading: false, error: error2 });
                onLoginError === null || onLoginError === void 0 ? void 0 : onLoginError(error2);
                reject(error2);
              } }));
            } catch (e) {
              const error2 = e;
              setLoginState({ loading: false, error: error2 });
              onLoginError === null || onLoginError === void 0 ? void 0 : onLoginError(error2);
              reject(error2);
            }
          });
          onLogin === null || onLogin === void 0 ? void 0 : onLogin(() => loginPromise);
        }), [onLogin, onLoginSuccess, onLoginError, authenticate]);
        const logout = react_1.default.useCallback((options) => __awaiter(void 0, void 0, void 0, function* () {
          const authClient = getAuth();
          if (!authClient) {
            throw new Error("Auth client not initialized");
          }
          yield authClient.logout(options);
          yield authenticate();
          onLoggedOut === null || onLoggedOut === void 0 ? void 0 : onLoggedOut();
        }), [onLoggedOut]);
        react_1.default.useEffect(() => agentManager.subscribeAgentState((state) => {
          if (network.current !== state.network) {
            network.current = state.network;
            authenticate();
          }
        }), []);
        return {
          authenticated,
          authenticating,
          identity: identity2,
          error,
          login,
          logout,
          authenticate,
          loginLoading: loginState.loading,
          loginError: loginState.error
        };
      };
      return {
        useUserPrincipal,
        useAuthState,
        useAuth
      };
    };
    exports.authHooks = authHooks;
  }
});

// node_modules/@ic-reactor/react/dist/helpers/extractActorContext.js
var require_extractActorContext = __commonJS({
  "node_modules/@ic-reactor/react/dist/helpers/extractActorContext.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractActorContext = void 0;
    var react_1 = __importDefault(require_react());
    function extractActorContext(actorContext) {
      const useActorContext = () => {
        const context = react_1.default.useContext(actorContext);
        if (!context) {
          throw new Error("Actor hooks must be used within a ActorProvider");
        }
        return context;
      };
      const initialize = () => useActorContext().initialize();
      const useMethodNames = () => useActorContext().useMethodNames();
      const useMethodAttributes = () => useActorContext().useMethodAttributes();
      const useActorStore = (selector = (s) => s) => {
        return useActorContext().useActorStore(selector);
      };
      const useActorState = () => useActorContext().useActorState();
      const useMethod = (args) => useActorContext().useMethod(args);
      const useQueryCall = (args) => useActorContext().useQueryCall(args);
      const useUpdateCall = (args) => useActorContext().useUpdateCall(args);
      const useVisitMethod = (functionName) => useActorContext().useVisitMethod(functionName);
      const useVisitService = () => useActorContext().useVisitService();
      const useActorInterface = () => useActorContext().useActorInterface();
      return {
        useActorStore,
        useActorState,
        useMethod,
        useMethodNames,
        useMethodAttributes,
        useQueryCall,
        useUpdateCall,
        useVisitMethod,
        useVisitService,
        useActorInterface,
        initialize
      };
    }
    exports.extractActorContext = extractActorContext;
  }
});

// node_modules/@ic-reactor/react/dist/helpers/extractAgentContext.js
var require_extractAgentContext = __commonJS({
  "node_modules/@ic-reactor/react/dist/helpers/extractAgentContext.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractAgentContext = void 0;
    var react_1 = __importDefault(require_react());
    var extractAgentContext = (agentContext) => {
      const useAgentContext = () => {
        const context = react_1.default.useContext(agentContext);
        if (!context) {
          throw new Error("Agent hooks must be used within a AgentProvider");
        }
        return context;
      };
      const useAgentManager = () => {
        const context = useAgentContext();
        return context.agentManager;
      };
      const useAgent = () => useAgentContext().useAgent();
      const useAuthState = () => useAgentContext().useAuthState();
      const useAgentState = () => useAgentContext().useAgentState();
      const useAuth = (args) => useAgentContext().useAuth(args);
      const useUserPrincipal = () => useAgentContext().useUserPrincipal();
      return {
        useAgent,
        useAuthState,
        useAgentState,
        useAuth,
        useAgentManager,
        useUserPrincipal
      };
    };
    exports.extractAgentContext = extractAgentContext;
  }
});

// node_modules/@ic-reactor/react/dist/helpers/index.js
var require_helpers = __commonJS({
  "node_modules/@ic-reactor/react/dist/helpers/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_agentHooks(), exports);
    __exportStar(require_actorHooks(), exports);
    __exportStar(require_authHooks(), exports);
    __exportStar(require_extractActorContext(), exports);
    __exportStar(require_extractAgentContext(), exports);
  }
});

// node_modules/@ic-reactor/react/dist/createReactor.js
var require_createReactor = __commonJS({
  "node_modules/@ic-reactor/react/dist/createReactor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createReactor = void 0;
    var core_1 = require_dist();
    var helpers_1 = require_helpers();
    var createReactor = (config) => {
      const actorManager = (0, core_1.createReactorStore)(config);
      const getVisitFunction = () => {
        return actorManager.visitFunction;
      };
      const getAgent = () => {
        return actorManager.agentManager.getAgent();
      };
      return Object.assign(Object.assign(Object.assign({
        getAgent,
        getVisitFunction
      }, (0, helpers_1.actorHooks)(actorManager)), (0, helpers_1.authHooks)(actorManager.agentManager)), (0, helpers_1.agentHooks)(actorManager.agentManager));
    };
    exports.createReactor = createReactor;
  }
});

// node_modules/@ic-reactor/react/dist/context/agent/create.js
var require_create = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/agent/create.js"(exports) {
    "use strict";
    var __rest2 = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createAgentContext = void 0;
    var react_1 = __importDefault(require_react());
    var core_1 = require_dist();
    var agentHooks_1 = require_agentHooks();
    var authHooks_1 = require_authHooks();
    var extractAgentContext_1 = require_extractAgentContext();
    function createAgentContext(config = {}) {
      const { disableAuthenticateOnMount: defaultDisable } = config, contextOptions = __rest2(config, ["disableAuthenticateOnMount"]);
      const AgentContext = react_1.default.createContext(null);
      const AgentProvider = (_a) => {
        var { children, agentManager: mybeAgentManager, disableAuthenticateOnMount = defaultDisable !== null && defaultDisable !== void 0 ? defaultDisable : false } = _a, options = __rest2(_a, ["children", "agentManager", "disableAuthenticateOnMount"]);
        const hooks = react_1.default.useMemo(() => {
          const agentManager = mybeAgentManager !== null && mybeAgentManager !== void 0 ? mybeAgentManager : (0, core_1.createAgentManager)(Object.assign(Object.assign({}, options), contextOptions));
          if (!disableAuthenticateOnMount) {
            agentManager.authenticate();
          }
          return Object.assign(Object.assign(Object.assign({}, (0, agentHooks_1.agentHooks)(agentManager)), (0, authHooks_1.authHooks)(agentManager)), { agentManager });
        }, []);
        return react_1.default.createElement(AgentContext.Provider, { value: hooks }, children);
      };
      AgentProvider.displayName = "AgentProvider";
      return Object.assign({ AgentProvider }, (0, extractAgentContext_1.extractAgentContext)(AgentContext));
    }
    exports.createAgentContext = createAgentContext;
  }
});

// node_modules/@ic-reactor/react/dist/context/agent/provider.js
var require_provider = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/agent/provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentProvider = void 0;
    var _1 = require_agent3();
    exports.AgentProvider = _1.AgentHooks.AgentProvider;
  }
});

// node_modules/@ic-reactor/react/dist/context/agent/hooks/useAgent.js
var require_useAgent = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/agent/hooks/useAgent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useAgent = void 0;
    var __1 = require_agent3();
    exports.useAgent = __1.AgentHooks.useAgent;
  }
});

// node_modules/@ic-reactor/react/dist/context/agent/hooks/useAgentState.js
var require_useAgentState = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/agent/hooks/useAgentState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useAgentState = void 0;
    var __1 = require_agent3();
    exports.useAgentState = __1.AgentHooks.useAgentState;
  }
});

// node_modules/@ic-reactor/react/dist/context/agent/hooks/useAgentManager.js
var require_useAgentManager = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/agent/hooks/useAgentManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useAgentManager = void 0;
    var __1 = require_agent3();
    exports.useAgentManager = __1.AgentHooks.useAgentManager;
  }
});

// node_modules/@ic-reactor/react/dist/context/agent/hooks/useAuth.js
var require_useAuth = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/agent/hooks/useAuth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useAuth = void 0;
    var __1 = require_agent3();
    exports.useAuth = __1.AgentHooks.useAuth;
  }
});

// node_modules/@ic-reactor/react/dist/context/agent/hooks/useAuthState.js
var require_useAuthState = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/agent/hooks/useAuthState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useAuthState = void 0;
    var __1 = require_agent3();
    exports.useAuthState = __1.AgentHooks.useAuthState;
  }
});

// node_modules/@ic-reactor/react/dist/context/agent/hooks/useUserPrincipal.js
var require_useUserPrincipal = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/agent/hooks/useUserPrincipal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useUserPrincipal = void 0;
    var __1 = require_agent3();
    exports.useUserPrincipal = __1.AgentHooks.useUserPrincipal;
  }
});

// node_modules/@ic-reactor/react/dist/context/agent/index.js
var require_agent3 = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/agent/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AgentHooks = exports.createAgentContext = void 0;
    var create_1 = require_create();
    Object.defineProperty(exports, "createAgentContext", { enumerable: true, get: function() {
      return create_1.createAgentContext;
    } });
    exports.AgentHooks = (0, create_1.createAgentContext)();
    __exportStar(require_provider(), exports);
    __exportStar(require_useAgent(), exports);
    __exportStar(require_useAgentState(), exports);
    __exportStar(require_useAgentManager(), exports);
    __exportStar(require_useAuth(), exports);
    __exportStar(require_useAuthState(), exports);
    __exportStar(require_useUserPrincipal(), exports);
  }
});

// node_modules/@ic-reactor/react/dist/context/adapter/create.js
var require_create2 = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/adapter/create.js"(exports) {
    "use strict";
    var __rest2 = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createAdapterContext = void 0;
    var react_1 = __importDefault(require_react());
    var agent_1 = require_agent3();
    var core_1 = require_dist();
    function createAdapterContext(config = {}) {
      const { withParser: _withParser, didjsCanisterId: _didjsCanisterId } = config, defaultConfig = __rest2(config, ["withParser", "didjsCanisterId"]);
      const CandidAdapterContext = react_1.default.createContext(null);
      const useCandidAdapter = () => {
        const candidAdapter = react_1.default.useContext(CandidAdapterContext);
        return candidAdapter;
      };
      const CandidAdapterProvider = (_a) => {
        var { children, withParser = _withParser, loadingComponent = react_1.default.createElement("div", null, "Loading Parser..."), didjsCanisterId = _didjsCanisterId } = _a, restConfig = __rest2(_a, ["children", "withParser", "loadingComponent", "didjsCanisterId"]);
        const config2 = react_1.default.useMemo(() => Object.assign(Object.assign({}, defaultConfig), restConfig), [defaultConfig, restConfig]);
        const [initalized, setInitialized] = react_1.default.useState(false);
        const agentManager = (0, agent_1.useAgentManager)();
        const candidAdapter = react_1.default.useMemo(() => (0, core_1.createCandidAdapter)(Object.assign({ agentManager, didjsCanisterId }, config2)), [didjsCanisterId, agentManager]);
        react_1.default.useEffect(() => {
          if (withParser) {
            candidAdapter.initializeParser().then(() => setInitialized(true));
          } else {
            setInitialized(true);
          }
        }, []);
        return react_1.default.createElement(CandidAdapterContext.Provider, { value: candidAdapter }, initalized ? children : loadingComponent);
      };
      CandidAdapterProvider.displayName = "CandidAdapterProvider";
      return {
        useCandidAdapter,
        CandidAdapterProvider
      };
    }
    exports.createAdapterContext = createAdapterContext;
  }
});

// node_modules/@ic-reactor/react/dist/context/adapter/provider.js
var require_provider2 = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/adapter/provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CandidAdapterProvider = void 0;
    var _1 = require_adapter2();
    exports.CandidAdapterProvider = _1.AdapterHooks.CandidAdapterProvider;
  }
});

// node_modules/@ic-reactor/react/dist/context/adapter/hooks/useCandidAdapter.js
var require_useCandidAdapter = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/adapter/hooks/useCandidAdapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useCandidAdapter = void 0;
    var __1 = require_adapter2();
    exports.useCandidAdapter = __1.AdapterHooks.useCandidAdapter;
  }
});

// node_modules/@ic-reactor/react/dist/context/adapter/index.js
var require_adapter2 = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/adapter/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AdapterHooks = exports.createAdapterContext = void 0;
    var create_1 = require_create2();
    Object.defineProperty(exports, "createAdapterContext", { enumerable: true, get: function() {
      return create_1.createAdapterContext;
    } });
    exports.AdapterHooks = (0, create_1.createAdapterContext)();
    __exportStar(require_provider2(), exports);
    __exportStar(require_useCandidAdapter(), exports);
  }
});

// node_modules/@ic-reactor/react/dist/hooks/useActor.js
var require_useActor = __commonJS({
  "node_modules/@ic-reactor/react/dist/hooks/useActor.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value2) {
        return value2 instanceof P ? value2 : new P(function(resolve) {
          resolve(value2);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __rest2 = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useActor = void 0;
    var core_1 = require_dist();
    var react_1 = require_react();
    var helpers_1 = require_helpers();
    var adapter_1 = require_adapter2();
    var agent_1 = require_agent3();
    var useActor = (config) => {
      const { canisterId, candidString, idlFactory: maybeIdlFactory } = config, actorConfig = __rest2(config, ["canisterId", "candidString", "idlFactory"]);
      if (!canisterId) {
        throw new Error("canisterId is required");
      }
      const [actorManager, setActorManager] = (0, react_1.useState)(null);
      (0, react_1.useEffect)(() => {
        if ((actorManager === null || actorManager === void 0 ? void 0 : actorManager.canisterId) !== canisterId.toString()) {
          setActorManager(null);
        }
        return actorManager === null || actorManager === void 0 ? void 0 : actorManager.cleanup();
      }, [canisterId, actorManager]);
      const [{ fetching, fetchError }, setState] = (0, react_1.useState)({
        fetching: false,
        fetchError: null
      });
      const candidAdapter = (0, adapter_1.useCandidAdapter)();
      const authenticating = (0, agent_1.useAuthState)().authenticating;
      const fetchCandid = (0, react_1.useCallback)(() => __awaiter(void 0, void 0, void 0, function* () {
        if (fetching)
          return;
        setState({
          fetching: true,
          fetchError: null
        });
        try {
          const { idlFactory } = yield candidAdapter.getCandidDefinition(canisterId);
          setState({
            fetching: false,
            fetchError: null
          });
          return idlFactory;
        } catch (err) {
          console.error(err);
          setState({
            fetchError: `Error fetching canister ${canisterId}`,
            fetching: false
          });
        }
      }), [canisterId]);
      const evaluateCandid = (0, react_1.useCallback)(() => __awaiter(void 0, void 0, void 0, function* () {
        try {
          const definition = yield candidAdapter.dynamicEvalJs(candidString);
          if (typeof (definition === null || definition === void 0 ? void 0 : definition.idlFactory) !== "function") {
            throw new Error("Error evaluating Candid definition");
          }
          return definition.idlFactory;
        } catch (err) {
          console.error(err);
          setState({
            fetchError: `Error evaluating Candid definition, ${err}`,
            fetching: false
          });
        }
      }), [candidString]);
      const agentManager = (0, agent_1.useAgentManager)();
      const initialActorManager = (0, react_1.useCallback)((idlFactory) => {
        if (authenticating || !idlFactory)
          return;
        const actorManager2 = (0, core_1.createActorManager)(Object.assign({
          agentManager,
          idlFactory,
          canisterId
        }, actorConfig));
        setActorManager(actorManager2);
      }, [canisterId, agentManager, authenticating]);
      const handleActorInitialization = (0, react_1.useCallback)(() => __awaiter(void 0, void 0, void 0, function* () {
        if (authenticating)
          return;
        if (maybeIdlFactory) {
          initialActorManager(maybeIdlFactory);
          return;
        }
        if (!candidAdapter) {
          throw new Error("CandidAdapter is necessary to fetch the Candid interface. Please ensure your application is wrapped with the CandidAdapterProvider, or provide the idlFactory directly.");
        }
        let idlFactory;
        if (candidString) {
          idlFactory = yield evaluateCandid();
        } else {
          idlFactory = yield fetchCandid();
        }
        initialActorManager(idlFactory);
      }), [fetchCandid, evaluateCandid, maybeIdlFactory, initialActorManager]);
      (0, react_1.useEffect)(() => {
        handleActorInitialization();
      }, [handleActorInitialization]);
      const hooks = (0, react_1.useMemo)(() => {
        if (!actorManager)
          return null;
        return (0, helpers_1.actorHooks)(actorManager);
      }, [actorManager]);
      return { hooks, authenticating, fetching, fetchError };
    };
    exports.useActor = useActor;
  }
});

// node_modules/@ic-reactor/react/dist/context/actor/create.js
var require_create3 = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/actor/create.js"(exports) {
    "use strict";
    var __rest2 = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createActorContext = void 0;
    var react_1 = __importDefault(require_react());
    var useActor_1 = require_useActor();
    var extractActorContext_1 = require_extractActorContext();
    function createActorContext(contextConfig = {}) {
      const { canisterId: defaultCanisterId } = contextConfig, defaultConfig = __rest2(contextConfig, ["canisterId"]);
      const ActorContext = react_1.default.createContext(null);
      const ActorProvider = (_a) => {
        var { children, canisterId = defaultCanisterId, loadingComponent = react_1.default.createElement("div", null, "Fetching canister..."), authenticatingComponent = react_1.default.createElement("div", null, "Authenticating...") } = _a, restConfig = __rest2(_a, ["children", "canisterId", "loadingComponent", "authenticatingComponent"]);
        if (!canisterId) {
          throw new Error("canisterId is required");
        }
        const config = react_1.default.useMemo(() => Object.assign(Object.assign({}, defaultConfig), restConfig), [defaultConfig, restConfig]);
        const { fetchError, authenticating, hooks } = (0, useActor_1.useActor)(Object.assign({ canisterId }, config));
        return react_1.default.createElement(ActorContext.Provider, { value: hooks }, hooks === null ? fetchError ? fetchError : authenticating ? authenticatingComponent : loadingComponent : children);
      };
      ActorProvider.displayName = "ActorProvider";
      const ActorHookProvider = ({ hooks, children }) => {
        return react_1.default.createElement(ActorContext.Provider, { value: hooks }, children);
      };
      return Object.assign({
        ActorProvider,
        ActorHookProvider
      }, (0, extractActorContext_1.extractActorContext)(ActorContext));
    }
    exports.createActorContext = createActorContext;
  }
});

// node_modules/@ic-reactor/react/dist/context/actor/provider.js
var require_provider3 = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/actor/provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ActorHookProvider = exports.ActorProvider = void 0;
    var _1 = require_actor2();
    exports.ActorProvider = _1.ActorHooks.ActorProvider;
    exports.ActorHookProvider = _1.ActorHooks.ActorHookProvider;
  }
});

// node_modules/@ic-reactor/react/dist/context/actor/hooks/useMethodNames.js
var require_useMethodNames = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/actor/hooks/useMethodNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useMethodNames = void 0;
    var __1 = require_actor2();
    var useMethodNames = () => __1.ActorHooks.useMethodNames();
    exports.useMethodNames = useMethodNames;
  }
});

// node_modules/@ic-reactor/react/dist/context/actor/hooks/useQueryCall.js
var require_useQueryCall = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/actor/hooks/useQueryCall.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useQueryCall = void 0;
    var __1 = require_actor2();
    function useQueryCall(args) {
      return __1.ActorHooks.useQueryCall(args);
    }
    exports.useQueryCall = useQueryCall;
  }
});

// node_modules/@ic-reactor/react/dist/context/actor/hooks/useUpdateCall.js
var require_useUpdateCall = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/actor/hooks/useUpdateCall.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useUpdateCall = void 0;
    var __1 = require_actor2();
    function useUpdateCall(args) {
      return __1.ActorHooks.useUpdateCall(args);
    }
    exports.useUpdateCall = useUpdateCall;
  }
});

// node_modules/@ic-reactor/react/dist/context/actor/hooks/useMethodAttributes.js
var require_useMethodAttributes = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/actor/hooks/useMethodAttributes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useMethodAttributes = void 0;
    var __1 = require_actor2();
    var useMethodAttributes = () => __1.ActorHooks.useMethodAttributes();
    exports.useMethodAttributes = useMethodAttributes;
  }
});

// node_modules/@ic-reactor/react/dist/context/actor/hooks/useActorStore.js
var require_useActorStore = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/actor/hooks/useActorStore.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useActorStore = void 0;
    var __1 = require_actor2();
    exports.useActorStore = __1.ActorHooks.useActorStore;
  }
});

// node_modules/@ic-reactor/react/dist/context/actor/hooks/useActorState.js
var require_useActorState = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/actor/hooks/useActorState.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useActorState = void 0;
    var __1 = require_actor2();
    exports.useActorState = __1.ActorHooks.useActorState;
  }
});

// node_modules/@ic-reactor/react/dist/context/actor/hooks/useVisitMethod.js
var require_useVisitMethod = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/actor/hooks/useVisitMethod.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useVisitMethod = void 0;
    var __1 = require_actor2();
    function useVisitMethod(functionName) {
      return __1.ActorHooks.useVisitMethod(functionName);
    }
    exports.useVisitMethod = useVisitMethod;
  }
});

// node_modules/@ic-reactor/react/dist/context/actor/hooks/useVisitService.js
var require_useVisitService = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/actor/hooks/useVisitService.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useVisitService = void 0;
    var __1 = require_actor2();
    function useVisitService() {
      return __1.ActorHooks.useVisitService();
    }
    exports.useVisitService = useVisitService;
  }
});

// node_modules/@ic-reactor/react/dist/context/actor/hooks/useActorInterface.js
var require_useActorInterface = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/actor/hooks/useActorInterface.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useActorInterface = void 0;
    var __1 = require_actor2();
    function useActorInterface() {
      return __1.ActorHooks.useActorInterface();
    }
    exports.useActorInterface = useActorInterface;
  }
});

// node_modules/@ic-reactor/react/dist/context/actor/hooks/useMethod.js
var require_useMethod = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/actor/hooks/useMethod.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useMethod = void 0;
    var __1 = require_actor2();
    function useMethod(args) {
      return __1.ActorHooks.useMethod(args);
    }
    exports.useMethod = useMethod;
  }
});

// node_modules/@ic-reactor/react/dist/context/actor/index.js
var require_actor2 = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/actor/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ActorHooks = exports.createActorContext = void 0;
    var create_1 = require_create3();
    Object.defineProperty(exports, "createActorContext", { enumerable: true, get: function() {
      return create_1.createActorContext;
    } });
    exports.ActorHooks = (0, create_1.createActorContext)();
    __exportStar(require_provider3(), exports);
    __exportStar(require_useMethodNames(), exports);
    __exportStar(require_useQueryCall(), exports);
    __exportStar(require_useUpdateCall(), exports);
    __exportStar(require_useMethodAttributes(), exports);
    __exportStar(require_useActorStore(), exports);
    __exportStar(require_useActorState(), exports);
    __exportStar(require_useVisitMethod(), exports);
    __exportStar(require_useVisitService(), exports);
    __exportStar(require_useActorInterface(), exports);
    __exportStar(require_useMethod(), exports);
  }
});

// node_modules/@ic-reactor/react/dist/hooks/index.js
var require_hooks = __commonJS({
  "node_modules/@ic-reactor/react/dist/hooks/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_useActor(), exports);
  }
});

// node_modules/@ic-reactor/react/dist/context/actor/types.js
var require_types6 = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/actor/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@ic-reactor/react/dist/context/agent/types.js
var require_types7 = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/agent/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@ic-reactor/react/dist/context/adapter/types.js
var require_types8 = __commonJS({
  "node_modules/@ic-reactor/react/dist/context/adapter/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@ic-reactor/react/dist/helpers/types.js
var require_types9 = __commonJS({
  "node_modules/@ic-reactor/react/dist/helpers/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@ic-reactor/react/dist/hooks/types.js
var require_types10 = __commonJS({
  "node_modules/@ic-reactor/react/dist/hooks/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@ic-reactor/react/dist/types.js
var require_types11 = __commonJS({
  "node_modules/@ic-reactor/react/dist/types.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_types6(), exports);
    __exportStar(require_types7(), exports);
    __exportStar(require_types8(), exports);
    __exportStar(require_types9(), exports);
    __exportStar(require_types10(), exports);
    __exportStar(require_types5(), exports);
  }
});

// node_modules/@ic-reactor/react/dist/core.js
var require_core = __commonJS({
  "node_modules/@ic-reactor/react/dist/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createReactorCore = exports.createCandidAdapter = exports.createAgentManager = exports.createActorManager = exports.createReactorStore = void 0;
    var core_1 = require_dist();
    Object.defineProperty(exports, "createReactorStore", { enumerable: true, get: function() {
      return core_1.createReactorStore;
    } });
    Object.defineProperty(exports, "createActorManager", { enumerable: true, get: function() {
      return core_1.createActorManager;
    } });
    Object.defineProperty(exports, "createAgentManager", { enumerable: true, get: function() {
      return core_1.createAgentManager;
    } });
    Object.defineProperty(exports, "createCandidAdapter", { enumerable: true, get: function() {
      return core_1.createCandidAdapter;
    } });
    Object.defineProperty(exports, "createReactorCore", { enumerable: true, get: function() {
      return core_1.createReactorCore;
    } });
  }
});

// node_modules/@ic-reactor/react/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@ic-reactor/react/dist/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utils = exports.core = exports.types = exports.helpers = void 0;
    __exportStar(require_createReactor(), exports);
    __exportStar(require_actor2(), exports);
    __exportStar(require_adapter2(), exports);
    __exportStar(require_agent3(), exports);
    __exportStar(require_hooks(), exports);
    exports.helpers = __importStar(require_helpers());
    exports.types = __importStar(require_types11());
    exports.core = __importStar(require_core());
    exports.utils = __importStar(require_utils2());
  }
});
export default require_dist2();
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@ic-reactor_react.js.map
